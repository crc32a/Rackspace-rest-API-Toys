#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Tue Mar 13 17:51:01 2012 by generateDS.py version 2.7b.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class loadBalancers(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, loadBalancer=None, link=None):
        if loadBalancer is None:
            self.loadBalancer = []
        else:
            self.loadBalancer = loadBalancer
        if link is None:
            self.link = []
        else:
            self.link = link
    def factory(*args_, **kwargs_):
        if loadBalancers.subclass:
            return loadBalancers.subclass(*args_, **kwargs_)
        else:
            return loadBalancers(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_loadBalancer(self): return self.loadBalancer
    def set_loadBalancer(self, loadBalancer): self.loadBalancer = loadBalancer
    def add_loadBalancer(self, value): self.loadBalancer.append(value)
    def insert_loadBalancer(self, index, value): self.loadBalancer[index] = value
    def get_link(self): return self.link
    def set_link(self, link): self.link = link
    def add_link(self, value): self.link.append(value)
    def insert_link(self, index, value): self.link[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='loadBalancers', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='loadBalancers')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='loadBalancers'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='loadBalancers', fromsubclass_=False):
        for loadBalancer_ in self.loadBalancer:
            loadBalancer_.export(outfile, level, namespace_, name_='loadBalancer')
        for link_ in self.link:
            link_.export(outfile, level, namespace_, name_='link')
    def hasContent_(self):
        if (
            self.loadBalancer or
            self.link
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='loadBalancers'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('loadBalancer=[\n')
        level += 1
        for loadBalancer_ in self.loadBalancer:
            showIndent(outfile, level)
            outfile.write('model_.loadBalancer(\n')
            loadBalancer_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('link=[\n')
        level += 1
        for link_ in self.link:
            showIndent(outfile, level)
            outfile.write('model_.link(\n')
            link_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'loadBalancer':
            obj_ = loadBalancer.factory()
            obj_.build(child_)
            self.loadBalancer.append(obj_)
        elif nodeName_ == 'link':
            obj_ = linkType.factory()
            obj_.build(child_)
            self.link.append(obj_)
# end class loadBalancers


class loadBalancer(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, status=None, protocol=None, name=None, algorithm=None, isSticky=None, id=None, nodeCount=None, port=None, virtualIps=None, nodes=None, metadata=None, loadBalancerUsage=None, sessionPersistence=None, healthMonitor=None, connectionThrottle=None, accessList=None, cluster=None, created=None, updated=None, connectionLogging=None, sourceAddresses=None, sslTermination=None):
        self.status = _cast(None, status)
        self.protocol = _cast(None, protocol)
        self.name = _cast(None, name)
        self.algorithm = _cast(None, algorithm)
        self.isSticky = _cast(bool, isSticky)
        self.id = _cast(int, id)
        self.nodeCount = _cast(int, nodeCount)
        self.port = _cast(int, port)
        self.virtualIps = virtualIps
        self.nodes = nodes
        self.metadata = metadata
        self.loadBalancerUsage = loadBalancerUsage
        self.sessionPersistence = sessionPersistence
        self.healthMonitor = healthMonitor
        self.connectionThrottle = connectionThrottle
        self.accessList = accessList
        self.cluster = cluster
        self.created = created
        self.updated = updated
        self.connectionLogging = connectionLogging
        self.sourceAddresses = sourceAddresses
        self.sslTermination = sslTermination
    def factory(*args_, **kwargs_):
        if loadBalancer.subclass:
            return loadBalancer.subclass(*args_, **kwargs_)
        else:
            return loadBalancer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_virtualIps(self): return self.virtualIps
    def set_virtualIps(self, virtualIps): self.virtualIps = virtualIps
    def get_nodes(self): return self.nodes
    def set_nodes(self, nodes): self.nodes = nodes
    def get_metadata(self): return self.metadata
    def set_metadata(self, metadata): self.metadata = metadata
    def get_loadBalancerUsage(self): return self.loadBalancerUsage
    def set_loadBalancerUsage(self, loadBalancerUsage): self.loadBalancerUsage = loadBalancerUsage
    def get_sessionPersistence(self): return self.sessionPersistence
    def set_sessionPersistence(self, sessionPersistence): self.sessionPersistence = sessionPersistence
    def get_healthMonitor(self): return self.healthMonitor
    def set_healthMonitor(self, healthMonitor): self.healthMonitor = healthMonitor
    def get_connectionThrottle(self): return self.connectionThrottle
    def set_connectionThrottle(self, connectionThrottle): self.connectionThrottle = connectionThrottle
    def get_accessList(self): return self.accessList
    def set_accessList(self, accessList): self.accessList = accessList
    def get_cluster(self): return self.cluster
    def set_cluster(self, cluster): self.cluster = cluster
    def get_created(self): return self.created
    def set_created(self, created): self.created = created
    def get_updated(self): return self.updated
    def set_updated(self, updated): self.updated = updated
    def get_connectionLogging(self): return self.connectionLogging
    def set_connectionLogging(self, connectionLogging): self.connectionLogging = connectionLogging
    def get_sourceAddresses(self): return self.sourceAddresses
    def set_sourceAddresses(self, sourceAddresses): self.sourceAddresses = sourceAddresses
    def get_sslTermination(self): return self.sslTermination
    def set_sslTermination(self, sslTermination): self.sslTermination = sslTermination
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_algorithm(self): return self.algorithm
    def set_algorithm(self, algorithm): self.algorithm = algorithm
    def get_isSticky(self): return self.isSticky
    def set_isSticky(self, isSticky): self.isSticky = isSticky
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_nodeCount(self): return self.nodeCount
    def set_nodeCount(self, nodeCount): self.nodeCount = nodeCount
    def get_port(self): return self.port
    def set_port(self, port): self.port = port
    def export(self, outfile, level, namespace_='tns:', name_='loadBalancer', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='loadBalancer')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='loadBalancer'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (self.gds_format_string(quote_attrib(self.status).encode(ExternalEncoding), input_name='status'), ))
        if self.protocol is not None and 'protocol' not in already_processed:
            already_processed.append('protocol')
            outfile.write(' protocol=%s' % (self.gds_format_string(quote_attrib(self.protocol).encode(ExternalEncoding), input_name='protocol'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.algorithm is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            outfile.write(' algorithm=%s' % (self.gds_format_string(quote_attrib(self.algorithm).encode(ExternalEncoding), input_name='algorithm'), ))
        if self.isSticky is not None and 'isSticky' not in already_processed:
            already_processed.append('isSticky')
            outfile.write(' isSticky="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.isSticky)), input_name='isSticky'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.nodeCount is not None and 'nodeCount' not in already_processed:
            already_processed.append('nodeCount')
            outfile.write(' nodeCount="%s"' % self.gds_format_integer(self.nodeCount, input_name='nodeCount'))
        if self.port is not None and 'port' not in already_processed:
            already_processed.append('port')
            outfile.write(' port="%s"' % self.gds_format_integer(self.port, input_name='port'))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='loadBalancer', fromsubclass_=False):
        if self.virtualIps is not None:
            self.virtualIps.export(outfile, level, namespace_, name_='virtualIps')
        if self.nodes is not None:
            self.nodes.export(outfile, level, namespace_, name_='nodes')
        if self.metadata is not None:
            self.metadata.export(outfile, level, namespace_, name_='metadata')
        if self.loadBalancerUsage is not None:
            self.loadBalancerUsage.export(outfile, level, namespace_, name_='loadBalancerUsage')
        if self.sessionPersistence is not None:
            self.sessionPersistence.export(outfile, level, namespace_, name_='sessionPersistence')
        if self.healthMonitor is not None:
            self.healthMonitor.export(outfile, level, namespace_, name_='healthMonitor')
        if self.connectionThrottle is not None:
            self.connectionThrottle.export(outfile, level, namespace_, name_='connectionThrottle')
        if self.accessList is not None:
            self.accessList.export(outfile, level, namespace_, name_='accessList')
        if self.cluster is not None:
            self.cluster.export(outfile, level, namespace_, name_='cluster')
        if self.created is not None:
            self.created.export(outfile, level, namespace_, name_='created')
        if self.updated is not None:
            self.updated.export(outfile, level, namespace_, name_='updated')
        if self.connectionLogging is not None:
            self.connectionLogging.export(outfile, level, namespace_, name_='connectionLogging')
        if self.sourceAddresses is not None:
            self.sourceAddresses.export(outfile, level, namespace_, name_='sourceAddresses')
        if self.sslTermination is not None:
            self.sslTermination.export(outfile, level, namespace_, name_='sslTermination')
    def hasContent_(self):
        if (
            self.virtualIps is not None or
            self.nodes is not None or
            self.metadata is not None or
            self.loadBalancerUsage is not None or
            self.sessionPersistence is not None or
            self.healthMonitor is not None or
            self.connectionThrottle is not None or
            self.accessList is not None or
            self.cluster is not None or
            self.created is not None or
            self.updated is not None or
            self.connectionLogging is not None or
            self.sourceAddresses is not None or
            self.sslTermination is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='loadBalancer'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = "%s",\n' % (self.status,))
        if self.protocol is not None and 'protocol' not in already_processed:
            already_processed.append('protocol')
            showIndent(outfile, level)
            outfile.write('protocol = "%s",\n' % (self.protocol,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.algorithm is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            showIndent(outfile, level)
            outfile.write('algorithm = "%s",\n' % (self.algorithm,))
        if self.isSticky is not None and 'isSticky' not in already_processed:
            already_processed.append('isSticky')
            showIndent(outfile, level)
            outfile.write('isSticky = %s,\n' % (self.isSticky,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %d,\n' % (self.id,))
        if self.nodeCount is not None and 'nodeCount' not in already_processed:
            already_processed.append('nodeCount')
            showIndent(outfile, level)
            outfile.write('nodeCount = %d,\n' % (self.nodeCount,))
        if self.port is not None and 'port' not in already_processed:
            already_processed.append('port')
            showIndent(outfile, level)
            outfile.write('port = %d,\n' % (self.port,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.virtualIps is not None:
            showIndent(outfile, level)
            outfile.write('virtualIps=model_.virtualIps(\n')
            self.virtualIps.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.nodes is not None:
            showIndent(outfile, level)
            outfile.write('nodes=model_.nodes(\n')
            self.nodes.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.metadata is not None:
            showIndent(outfile, level)
            outfile.write('metadata=model_.metadata(\n')
            self.metadata.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.loadBalancerUsage is not None:
            showIndent(outfile, level)
            outfile.write('loadBalancerUsage=model_.loadBalancerUsage(\n')
            self.loadBalancerUsage.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sessionPersistence is not None:
            showIndent(outfile, level)
            outfile.write('sessionPersistence=model_.sessionPersistence(\n')
            self.sessionPersistence.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.healthMonitor is not None:
            showIndent(outfile, level)
            outfile.write('healthMonitor=model_.healthMonitor(\n')
            self.healthMonitor.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.connectionThrottle is not None:
            showIndent(outfile, level)
            outfile.write('connectionThrottle=model_.connectionThrottle(\n')
            self.connectionThrottle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.accessList is not None:
            showIndent(outfile, level)
            outfile.write('accessList=model_.accessList(\n')
            self.accessList.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.cluster is not None:
            showIndent(outfile, level)
            outfile.write('cluster=model_.cluster(\n')
            self.cluster.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.created is not None:
            showIndent(outfile, level)
            outfile.write('created=model_.created(\n')
            self.created.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.updated is not None:
            showIndent(outfile, level)
            outfile.write('updated=model_.updated(\n')
            self.updated.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.connectionLogging is not None:
            showIndent(outfile, level)
            outfile.write('connectionLogging=model_.connectionLogging(\n')
            self.connectionLogging.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sourceAddresses is not None:
            showIndent(outfile, level)
            outfile.write('sourceAddresses=model_.sourceAddresses(\n')
            self.sourceAddresses.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sslTermination is not None:
            showIndent(outfile, level)
            outfile.write('sslTermination=model_.sslTermination(\n')
            self.sslTermination.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('protocol', node)
        if value is not None and 'protocol' not in already_processed:
            already_processed.append('protocol')
            self.protocol = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('algorithm', node)
        if value is not None and 'algorithm' not in already_processed:
            already_processed.append('algorithm')
            self.algorithm = value
        value = find_attr_value_('isSticky', node)
        if value is not None and 'isSticky' not in already_processed:
            already_processed.append('isSticky')
            if value in ('true', '1'):
                self.isSticky = True
            elif value in ('false', '0'):
                self.isSticky = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            try:
                self.id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('nodeCount', node)
        if value is not None and 'nodeCount' not in already_processed:
            already_processed.append('nodeCount')
            try:
                self.nodeCount = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('port', node)
        if value is not None and 'port' not in already_processed:
            already_processed.append('port')
            try:
                self.port = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'virtualIps':
            obj_ = virtualIps.factory()
            obj_.build(child_)
            self.set_virtualIps(obj_)
        elif nodeName_ == 'nodes':
            obj_ = nodes.factory()
            obj_.build(child_)
            self.set_nodes(obj_)
        elif nodeName_ == 'metadata':
            obj_ = metadata.factory()
            obj_.build(child_)
            self.set_metadata(obj_)
        elif nodeName_ == 'loadBalancerUsage':
            obj_ = loadBalancerUsage.factory()
            obj_.build(child_)
            self.set_loadBalancerUsage(obj_)
        elif nodeName_ == 'sessionPersistence':
            obj_ = sessionPersistence.factory()
            obj_.build(child_)
            self.set_sessionPersistence(obj_)
        elif nodeName_ == 'healthMonitor':
            obj_ = healthMonitor.factory()
            obj_.build(child_)
            self.set_healthMonitor(obj_)
        elif nodeName_ == 'connectionThrottle':
            obj_ = connectionThrottle.factory()
            obj_.build(child_)
            self.set_connectionThrottle(obj_)
        elif nodeName_ == 'accessList':
            obj_ = accessList.factory()
            obj_.build(child_)
            self.set_accessList(obj_)
        elif nodeName_ == 'cluster':
            obj_ = cluster.factory()
            obj_.build(child_)
            self.set_cluster(obj_)
        elif nodeName_ == 'created':
            obj_ = created.factory()
            obj_.build(child_)
            self.set_created(obj_)
        elif nodeName_ == 'updated':
            obj_ = updated.factory()
            obj_.build(child_)
            self.set_updated(obj_)
        elif nodeName_ == 'connectionLogging':
            obj_ = connectionLogging.factory()
            obj_.build(child_)
            self.set_connectionLogging(obj_)
        elif nodeName_ == 'sourceAddresses':
            obj_ = sourceAddresses.factory()
            obj_.build(child_)
            self.set_sourceAddresses(obj_)
        elif nodeName_ == 'sslTermination':
            obj_ = sslTermination.factory()
            obj_.build(child_)
            self.set_sslTermination(obj_)
# end class loadBalancer


class sourceAddresses(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ipv4Public=None, ipv4Servicenet=None, ipv6Public=None, ipv6Servicenet=None):
        self.ipv4Public = _cast(None, ipv4Public)
        self.ipv4Servicenet = _cast(None, ipv4Servicenet)
        self.ipv6Public = _cast(None, ipv6Public)
        self.ipv6Servicenet = _cast(None, ipv6Servicenet)
        pass
    def factory(*args_, **kwargs_):
        if sourceAddresses.subclass:
            return sourceAddresses.subclass(*args_, **kwargs_)
        else:
            return sourceAddresses(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ipv4Public(self): return self.ipv4Public
    def set_ipv4Public(self, ipv4Public): self.ipv4Public = ipv4Public
    def get_ipv4Servicenet(self): return self.ipv4Servicenet
    def set_ipv4Servicenet(self, ipv4Servicenet): self.ipv4Servicenet = ipv4Servicenet
    def get_ipv6Public(self): return self.ipv6Public
    def set_ipv6Public(self, ipv6Public): self.ipv6Public = ipv6Public
    def get_ipv6Servicenet(self): return self.ipv6Servicenet
    def set_ipv6Servicenet(self, ipv6Servicenet): self.ipv6Servicenet = ipv6Servicenet
    def export(self, outfile, level, namespace_='tns:', name_='sourceAddresses', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sourceAddresses')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='sourceAddresses'):
        if self.ipv4Public is not None and 'ipv4Public' not in already_processed:
            already_processed.append('ipv4Public')
            outfile.write(' ipv4Public=%s' % (self.gds_format_string(quote_attrib(self.ipv4Public).encode(ExternalEncoding), input_name='ipv4Public'), ))
        if self.ipv4Servicenet is not None and 'ipv4Servicenet' not in already_processed:
            already_processed.append('ipv4Servicenet')
            outfile.write(' ipv4Servicenet=%s' % (self.gds_format_string(quote_attrib(self.ipv4Servicenet).encode(ExternalEncoding), input_name='ipv4Servicenet'), ))
        if self.ipv6Public is not None and 'ipv6Public' not in already_processed:
            already_processed.append('ipv6Public')
            outfile.write(' ipv6Public=%s' % (self.gds_format_string(quote_attrib(self.ipv6Public).encode(ExternalEncoding), input_name='ipv6Public'), ))
        if self.ipv6Servicenet is not None and 'ipv6Servicenet' not in already_processed:
            already_processed.append('ipv6Servicenet')
            outfile.write(' ipv6Servicenet=%s' % (self.gds_format_string(quote_attrib(self.ipv6Servicenet).encode(ExternalEncoding), input_name='ipv6Servicenet'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='sourceAddresses', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sourceAddresses'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ipv4Public is not None and 'ipv4Public' not in already_processed:
            already_processed.append('ipv4Public')
            showIndent(outfile, level)
            outfile.write('ipv4Public = "%s",\n' % (self.ipv4Public,))
        if self.ipv4Servicenet is not None and 'ipv4Servicenet' not in already_processed:
            already_processed.append('ipv4Servicenet')
            showIndent(outfile, level)
            outfile.write('ipv4Servicenet = "%s",\n' % (self.ipv4Servicenet,))
        if self.ipv6Public is not None and 'ipv6Public' not in already_processed:
            already_processed.append('ipv6Public')
            showIndent(outfile, level)
            outfile.write('ipv6Public = "%s",\n' % (self.ipv6Public,))
        if self.ipv6Servicenet is not None and 'ipv6Servicenet' not in already_processed:
            already_processed.append('ipv6Servicenet')
            showIndent(outfile, level)
            outfile.write('ipv6Servicenet = "%s",\n' % (self.ipv6Servicenet,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ipv4Public', node)
        if value is not None and 'ipv4Public' not in already_processed:
            already_processed.append('ipv4Public')
            self.ipv4Public = value
        value = find_attr_value_('ipv4Servicenet', node)
        if value is not None and 'ipv4Servicenet' not in already_processed:
            already_processed.append('ipv4Servicenet')
            self.ipv4Servicenet = value
        value = find_attr_value_('ipv6Public', node)
        if value is not None and 'ipv6Public' not in already_processed:
            already_processed.append('ipv6Public')
            self.ipv6Public = value
        value = find_attr_value_('ipv6Servicenet', node)
        if value is not None and 'ipv6Servicenet' not in already_processed:
            already_processed.append('ipv6Servicenet')
            self.ipv6Servicenet = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class sourceAddresses


class stats(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, connectTimeOut=None, dataTimedOut=None, connectFailure=None, keepAliveTimedOut=None, maxConn=None, connectError=None):
        self.connectTimeOut = _cast(int, connectTimeOut)
        self.dataTimedOut = _cast(int, dataTimedOut)
        self.connectFailure = _cast(int, connectFailure)
        self.keepAliveTimedOut = _cast(int, keepAliveTimedOut)
        self.maxConn = _cast(int, maxConn)
        self.connectError = _cast(int, connectError)
        pass
    def factory(*args_, **kwargs_):
        if stats.subclass:
            return stats.subclass(*args_, **kwargs_)
        else:
            return stats(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_connectTimeOut(self): return self.connectTimeOut
    def set_connectTimeOut(self, connectTimeOut): self.connectTimeOut = connectTimeOut
    def get_dataTimedOut(self): return self.dataTimedOut
    def set_dataTimedOut(self, dataTimedOut): self.dataTimedOut = dataTimedOut
    def get_connectFailure(self): return self.connectFailure
    def set_connectFailure(self, connectFailure): self.connectFailure = connectFailure
    def get_keepAliveTimedOut(self): return self.keepAliveTimedOut
    def set_keepAliveTimedOut(self, keepAliveTimedOut): self.keepAliveTimedOut = keepAliveTimedOut
    def get_maxConn(self): return self.maxConn
    def set_maxConn(self, maxConn): self.maxConn = maxConn
    def get_connectError(self): return self.connectError
    def set_connectError(self, connectError): self.connectError = connectError
    def export(self, outfile, level, namespace_='tns:', name_='stats', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='stats')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='stats'):
        if self.connectTimeOut is not None and 'connectTimeOut' not in already_processed:
            already_processed.append('connectTimeOut')
            outfile.write(' connectTimeOut="%s"' % self.gds_format_integer(self.connectTimeOut, input_name='connectTimeOut'))
        if self.dataTimedOut is not None and 'dataTimedOut' not in already_processed:
            already_processed.append('dataTimedOut')
            outfile.write(' dataTimedOut="%s"' % self.gds_format_integer(self.dataTimedOut, input_name='dataTimedOut'))
        if self.connectFailure is not None and 'connectFailure' not in already_processed:
            already_processed.append('connectFailure')
            outfile.write(' connectFailure="%s"' % self.gds_format_integer(self.connectFailure, input_name='connectFailure'))
        if self.keepAliveTimedOut is not None and 'keepAliveTimedOut' not in already_processed:
            already_processed.append('keepAliveTimedOut')
            outfile.write(' keepAliveTimedOut="%s"' % self.gds_format_integer(self.keepAliveTimedOut, input_name='keepAliveTimedOut'))
        if self.maxConn is not None and 'maxConn' not in already_processed:
            already_processed.append('maxConn')
            outfile.write(' maxConn="%s"' % self.gds_format_integer(self.maxConn, input_name='maxConn'))
        if self.connectError is not None and 'connectError' not in already_processed:
            already_processed.append('connectError')
            outfile.write(' connectError="%s"' % self.gds_format_integer(self.connectError, input_name='connectError'))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='stats', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='stats'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.connectTimeOut is not None and 'connectTimeOut' not in already_processed:
            already_processed.append('connectTimeOut')
            showIndent(outfile, level)
            outfile.write('connectTimeOut = %d,\n' % (self.connectTimeOut,))
        if self.dataTimedOut is not None and 'dataTimedOut' not in already_processed:
            already_processed.append('dataTimedOut')
            showIndent(outfile, level)
            outfile.write('dataTimedOut = %d,\n' % (self.dataTimedOut,))
        if self.connectFailure is not None and 'connectFailure' not in already_processed:
            already_processed.append('connectFailure')
            showIndent(outfile, level)
            outfile.write('connectFailure = %d,\n' % (self.connectFailure,))
        if self.keepAliveTimedOut is not None and 'keepAliveTimedOut' not in already_processed:
            already_processed.append('keepAliveTimedOut')
            showIndent(outfile, level)
            outfile.write('keepAliveTimedOut = %d,\n' % (self.keepAliveTimedOut,))
        if self.maxConn is not None and 'maxConn' not in already_processed:
            already_processed.append('maxConn')
            showIndent(outfile, level)
            outfile.write('maxConn = %d,\n' % (self.maxConn,))
        if self.connectError is not None and 'connectError' not in already_processed:
            already_processed.append('connectError')
            showIndent(outfile, level)
            outfile.write('connectError = %d,\n' % (self.connectError,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('connectTimeOut', node)
        if value is not None and 'connectTimeOut' not in already_processed:
            already_processed.append('connectTimeOut')
            try:
                self.connectTimeOut = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('dataTimedOut', node)
        if value is not None and 'dataTimedOut' not in already_processed:
            already_processed.append('dataTimedOut')
            try:
                self.dataTimedOut = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('connectFailure', node)
        if value is not None and 'connectFailure' not in already_processed:
            already_processed.append('connectFailure')
            try:
                self.connectFailure = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('keepAliveTimedOut', node)
        if value is not None and 'keepAliveTimedOut' not in already_processed:
            already_processed.append('keepAliveTimedOut')
            try:
                self.keepAliveTimedOut = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('maxConn', node)
        if value is not None and 'maxConn' not in already_processed:
            already_processed.append('maxConn')
            try:
                self.maxConn = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('connectError', node)
        if value is not None and 'connectError' not in already_processed:
            already_processed.append('connectError')
            try:
                self.connectError = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class stats


class connectionLogging(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, enabled=None):
        self.enabled = _cast(bool, enabled)
        pass
    def factory(*args_, **kwargs_):
        if connectionLogging.subclass:
            return connectionLogging.subclass(*args_, **kwargs_)
        else:
            return connectionLogging(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_enabled(self): return self.enabled
    def set_enabled(self, enabled): self.enabled = enabled
    def export(self, outfile, level, namespace_='tns:', name_='connectionLogging', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='connectionLogging')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='connectionLogging'):
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.append('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.enabled)), input_name='enabled'))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='connectionLogging', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='connectionLogging'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.append('enabled')
            showIndent(outfile, level)
            outfile.write('enabled = %s,\n' % (self.enabled,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.append('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class connectionLogging


class created(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, time=None):
        self.time = _cast(None, time)
        pass
    def factory(*args_, **kwargs_):
        if created.subclass:
            return created.subclass(*args_, **kwargs_)
        else:
            return created(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def export(self, outfile, level, namespace_='tns:', name_='created', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='created')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='created'):
        if self.time is not None and 'time' not in already_processed:
            already_processed.append('time')
            outfile.write(' time=%s' % (self.gds_format_string(quote_attrib(self.time).encode(ExternalEncoding), input_name='time'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='created', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='created'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.time is not None and 'time' not in already_processed:
            already_processed.append('time')
            showIndent(outfile, level)
            outfile.write('time = "%s",\n' % (self.time,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('time', node)
        if value is not None and 'time' not in already_processed:
            already_processed.append('time')
            self.time = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class created


class updated(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, time=None):
        self.time = _cast(None, time)
        pass
    def factory(*args_, **kwargs_):
        if updated.subclass:
            return updated.subclass(*args_, **kwargs_)
        else:
            return updated(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_time(self): return self.time
    def set_time(self, time): self.time = time
    def export(self, outfile, level, namespace_='tns:', name_='updated', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='updated')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='updated'):
        if self.time is not None and 'time' not in already_processed:
            already_processed.append('time')
            outfile.write(' time=%s' % (self.gds_format_string(quote_attrib(self.time).encode(ExternalEncoding), input_name='time'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='updated', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='updated'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.time is not None and 'time' not in already_processed:
            already_processed.append('time')
            showIndent(outfile, level)
            outfile.write('time = "%s",\n' % (self.time,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('time', node)
        if value is not None and 'time' not in already_processed:
            already_processed.append('time')
            self.time = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class updated


class healthMonitor(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, attemptsBeforeDeactivation=None, bodyRegex=None, statusRegex=None, delay=None, timeout=None, path=None, type_=None, id=None):
        self.attemptsBeforeDeactivation = _cast(int, attemptsBeforeDeactivation)
        self.bodyRegex = _cast(None, bodyRegex)
        self.statusRegex = _cast(None, statusRegex)
        self.delay = _cast(int, delay)
        self.timeout = _cast(int, timeout)
        self.path = _cast(None, path)
        self.type_ = _cast(None, type_)
        self.id = _cast(int, id)
        pass
    def factory(*args_, **kwargs_):
        if healthMonitor.subclass:
            return healthMonitor.subclass(*args_, **kwargs_)
        else:
            return healthMonitor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attemptsBeforeDeactivation(self): return self.attemptsBeforeDeactivation
    def set_attemptsBeforeDeactivation(self, attemptsBeforeDeactivation): self.attemptsBeforeDeactivation = attemptsBeforeDeactivation
    def get_bodyRegex(self): return self.bodyRegex
    def set_bodyRegex(self, bodyRegex): self.bodyRegex = bodyRegex
    def get_statusRegex(self): return self.statusRegex
    def set_statusRegex(self, statusRegex): self.statusRegex = statusRegex
    def get_delay(self): return self.delay
    def set_delay(self, delay): self.delay = delay
    def get_timeout(self): return self.timeout
    def set_timeout(self, timeout): self.timeout = timeout
    def get_path(self): return self.path
    def set_path(self, path): self.path = path
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='tns:', name_='healthMonitor', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='healthMonitor')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='healthMonitor'):
        if self.attemptsBeforeDeactivation is not None and 'attemptsBeforeDeactivation' not in already_processed:
            already_processed.append('attemptsBeforeDeactivation')
            outfile.write(' attemptsBeforeDeactivation="%s"' % self.gds_format_integer(self.attemptsBeforeDeactivation, input_name='attemptsBeforeDeactivation'))
        if self.bodyRegex is not None and 'bodyRegex' not in already_processed:
            already_processed.append('bodyRegex')
            outfile.write(' bodyRegex=%s' % (self.gds_format_string(quote_attrib(self.bodyRegex).encode(ExternalEncoding), input_name='bodyRegex'), ))
        if self.statusRegex is not None and 'statusRegex' not in already_processed:
            already_processed.append('statusRegex')
            outfile.write(' statusRegex=%s' % (self.gds_format_string(quote_attrib(self.statusRegex).encode(ExternalEncoding), input_name='statusRegex'), ))
        if self.delay is not None and 'delay' not in already_processed:
            already_processed.append('delay')
            outfile.write(' delay="%s"' % self.gds_format_integer(self.delay, input_name='delay'))
        if self.timeout is not None and 'timeout' not in already_processed:
            already_processed.append('timeout')
            outfile.write(' timeout="%s"' % self.gds_format_integer(self.timeout, input_name='timeout'))
        if self.path is not None and 'path' not in already_processed:
            already_processed.append('path')
            outfile.write(' path=%s' % (self.gds_format_string(quote_attrib(self.path).encode(ExternalEncoding), input_name='path'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='healthMonitor', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='healthMonitor'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.attemptsBeforeDeactivation is not None and 'attemptsBeforeDeactivation' not in already_processed:
            already_processed.append('attemptsBeforeDeactivation')
            showIndent(outfile, level)
            outfile.write('attemptsBeforeDeactivation = %d,\n' % (self.attemptsBeforeDeactivation,))
        if self.bodyRegex is not None and 'bodyRegex' not in already_processed:
            already_processed.append('bodyRegex')
            showIndent(outfile, level)
            outfile.write('bodyRegex = "%s",\n' % (self.bodyRegex,))
        if self.statusRegex is not None and 'statusRegex' not in already_processed:
            already_processed.append('statusRegex')
            showIndent(outfile, level)
            outfile.write('statusRegex = "%s",\n' % (self.statusRegex,))
        if self.delay is not None and 'delay' not in already_processed:
            already_processed.append('delay')
            showIndent(outfile, level)
            outfile.write('delay = %d,\n' % (self.delay,))
        if self.timeout is not None and 'timeout' not in already_processed:
            already_processed.append('timeout')
            showIndent(outfile, level)
            outfile.write('timeout = %d,\n' % (self.timeout,))
        if self.path is not None and 'path' not in already_processed:
            already_processed.append('path')
            showIndent(outfile, level)
            outfile.write('path = "%s",\n' % (self.path,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %d,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('attemptsBeforeDeactivation', node)
        if value is not None and 'attemptsBeforeDeactivation' not in already_processed:
            already_processed.append('attemptsBeforeDeactivation')
            try:
                self.attemptsBeforeDeactivation = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('bodyRegex', node)
        if value is not None and 'bodyRegex' not in already_processed:
            already_processed.append('bodyRegex')
            self.bodyRegex = value
        value = find_attr_value_('statusRegex', node)
        if value is not None and 'statusRegex' not in already_processed:
            already_processed.append('statusRegex')
            self.statusRegex = value
        value = find_attr_value_('delay', node)
        if value is not None and 'delay' not in already_processed:
            already_processed.append('delay')
            try:
                self.delay = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('timeout', node)
        if value is not None and 'timeout' not in already_processed:
            already_processed.append('timeout')
            try:
                self.timeout = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('path', node)
        if value is not None and 'path' not in already_processed:
            already_processed.append('path')
            self.path = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            try:
                self.id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class healthMonitor


class virtualIps(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, virtualIp=None):
        if virtualIp is None:
            self.virtualIp = []
        else:
            self.virtualIp = virtualIp
    def factory(*args_, **kwargs_):
        if virtualIps.subclass:
            return virtualIps.subclass(*args_, **kwargs_)
        else:
            return virtualIps(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_virtualIp(self): return self.virtualIp
    def set_virtualIp(self, virtualIp): self.virtualIp = virtualIp
    def add_virtualIp(self, value): self.virtualIp.append(value)
    def insert_virtualIp(self, index, value): self.virtualIp[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='virtualIps', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='virtualIps')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='virtualIps'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='virtualIps', fromsubclass_=False):
        for virtualIp_ in self.virtualIp:
            virtualIp_.export(outfile, level, namespace_, name_='virtualIp')
    def hasContent_(self):
        if (
            self.virtualIp
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='virtualIps'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('virtualIp=[\n')
        level += 1
        for virtualIp_ in self.virtualIp:
            showIndent(outfile, level)
            outfile.write('model_.virtualIp(\n')
            virtualIp_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'virtualIp':
            obj_ = virtualIp.factory()
            obj_.build(child_)
            self.virtualIp.append(obj_)
# end class virtualIps


class nodes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, node=None):
        if node is None:
            self.node = []
        else:
            self.node = node
    def factory(*args_, **kwargs_):
        if nodes.subclass:
            return nodes.subclass(*args_, **kwargs_)
        else:
            return nodes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_node(self): return self.node
    def set_node(self, node): self.node = node
    def add_node(self, value): self.node.append(value)
    def insert_node(self, index, value): self.node[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='nodes', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='nodes')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='nodes'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='nodes', fromsubclass_=False):
        for node_ in self.node:
            node_.export(outfile, level, namespace_, name_='node')
    def hasContent_(self):
        if (
            self.node
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='nodes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('node=[\n')
        level += 1
        for node_ in self.node:
            showIndent(outfile, level)
            outfile.write('model_.node(\n')
            node_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'node':
            obj_ = node.factory()
            obj_.build(child_)
            self.node.append(obj_)
# end class nodes


class sessionPersistence(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, persistenceType=None):
        self.persistenceType = _cast(None, persistenceType)
        pass
    def factory(*args_, **kwargs_):
        if sessionPersistence.subclass:
            return sessionPersistence.subclass(*args_, **kwargs_)
        else:
            return sessionPersistence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_persistenceType(self): return self.persistenceType
    def set_persistenceType(self, persistenceType): self.persistenceType = persistenceType
    def export(self, outfile, level, namespace_='tns:', name_='sessionPersistence', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sessionPersistence')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='sessionPersistence'):
        if self.persistenceType is not None and 'persistenceType' not in already_processed:
            already_processed.append('persistenceType')
            outfile.write(' persistenceType=%s' % (quote_attrib(self.persistenceType), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='sessionPersistence', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sessionPersistence'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.persistenceType is not None and 'persistenceType' not in already_processed:
            already_processed.append('persistenceType')
            showIndent(outfile, level)
            outfile.write('persistenceType = %s,\n' % (self.persistenceType,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('persistenceType', node)
        if value is not None and 'persistenceType' not in already_processed:
            already_processed.append('persistenceType')
            self.persistenceType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class sessionPersistence


class node(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, status=None, weight=None, id=None, address=None, type_=None, port=None, condition=None):
        self.status = _cast(None, status)
        self.weight = _cast(int, weight)
        self.id = _cast(int, id)
        self.address = _cast(None, address)
        self.type_ = _cast(None, type_)
        self.port = _cast(int, port)
        self.condition = _cast(None, condition)
        pass
    def factory(*args_, **kwargs_):
        if node.subclass:
            return node.subclass(*args_, **kwargs_)
        else:
            return node(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_weight(self): return self.weight
    def set_weight(self, weight): self.weight = weight
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_port(self): return self.port
    def set_port(self, port): self.port = port
    def get_condition(self): return self.condition
    def set_condition(self, condition): self.condition = condition
    def export(self, outfile, level, namespace_='tns:', name_='node', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='node')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='node'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.append('weight')
            outfile.write(' weight="%s"' % self.gds_format_integer(self.weight, input_name='weight'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.address is not None and 'address' not in already_processed:
            already_processed.append('address')
            outfile.write(' address=%s' % (self.gds_format_string(quote_attrib(self.address).encode(ExternalEncoding), input_name='address'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.port is not None and 'port' not in already_processed:
            already_processed.append('port')
            outfile.write(' port="%s"' % self.gds_format_integer(self.port, input_name='port'))
        if self.condition is not None and 'condition' not in already_processed:
            already_processed.append('condition')
            outfile.write(' condition=%s' % (quote_attrib(self.condition), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='node', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='node'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %s,\n' % (self.status,))
        if self.weight is not None and 'weight' not in already_processed:
            already_processed.append('weight')
            showIndent(outfile, level)
            outfile.write('weight = %d,\n' % (self.weight,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %d,\n' % (self.id,))
        if self.address is not None and 'address' not in already_processed:
            already_processed.append('address')
            showIndent(outfile, level)
            outfile.write('address = "%s",\n' % (self.address,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.port is not None and 'port' not in already_processed:
            already_processed.append('port')
            showIndent(outfile, level)
            outfile.write('port = %d,\n' % (self.port,))
        if self.condition is not None and 'condition' not in already_processed:
            already_processed.append('condition')
            showIndent(outfile, level)
            outfile.write('condition = %s,\n' % (self.condition,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            self.status = value
        value = find_attr_value_('weight', node)
        if value is not None and 'weight' not in already_processed:
            already_processed.append('weight')
            try:
                self.weight = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            try:
                self.id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('address', node)
        if value is not None and 'address' not in already_processed:
            already_processed.append('address')
            self.address = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('port', node)
        if value is not None and 'port' not in already_processed:
            already_processed.append('port')
            try:
                self.port = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('condition', node)
        if value is not None and 'condition' not in already_processed:
            already_processed.append('condition')
            self.condition = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class node


class virtualIp(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ipVersion=None, type_=None, id=None, address=None):
        self.ipVersion = _cast(None, ipVersion)
        self.type_ = _cast(None, type_)
        self.id = _cast(int, id)
        self.address = _cast(None, address)
        pass
    def factory(*args_, **kwargs_):
        if virtualIp.subclass:
            return virtualIp.subclass(*args_, **kwargs_)
        else:
            return virtualIp(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ipVersion(self): return self.ipVersion
    def set_ipVersion(self, ipVersion): self.ipVersion = ipVersion
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def export(self, outfile, level, namespace_='tns:', name_='virtualIp', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='virtualIp')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='virtualIp'):
        if self.ipVersion is not None and 'ipVersion' not in already_processed:
            already_processed.append('ipVersion')
            outfile.write(' ipVersion=%s' % (quote_attrib(self.ipVersion), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.address is not None and 'address' not in already_processed:
            already_processed.append('address')
            outfile.write(' address=%s' % (self.gds_format_string(quote_attrib(self.address).encode(ExternalEncoding), input_name='address'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='virtualIp', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='virtualIp'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ipVersion is not None and 'ipVersion' not in already_processed:
            already_processed.append('ipVersion')
            showIndent(outfile, level)
            outfile.write('ipVersion = %s,\n' % (self.ipVersion,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %d,\n' % (self.id,))
        if self.address is not None and 'address' not in already_processed:
            already_processed.append('address')
            showIndent(outfile, level)
            outfile.write('address = "%s",\n' % (self.address,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ipVersion', node)
        if value is not None and 'ipVersion' not in already_processed:
            already_processed.append('ipVersion')
            self.ipVersion = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            try:
                self.id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('address', node)
        if value is not None and 'address' not in already_processed:
            already_processed.append('address')
            self.address = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class virtualIp


class connectionThrottle(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, maxConnectionRate=None, minConnections=None, rateInterval=None, maxConnections=None):
        self.maxConnectionRate = _cast(int, maxConnectionRate)
        self.minConnections = _cast(int, minConnections)
        self.rateInterval = _cast(int, rateInterval)
        self.maxConnections = _cast(int, maxConnections)
        pass
    def factory(*args_, **kwargs_):
        if connectionThrottle.subclass:
            return connectionThrottle.subclass(*args_, **kwargs_)
        else:
            return connectionThrottle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_maxConnectionRate(self): return self.maxConnectionRate
    def set_maxConnectionRate(self, maxConnectionRate): self.maxConnectionRate = maxConnectionRate
    def get_minConnections(self): return self.minConnections
    def set_minConnections(self, minConnections): self.minConnections = minConnections
    def get_rateInterval(self): return self.rateInterval
    def set_rateInterval(self, rateInterval): self.rateInterval = rateInterval
    def get_maxConnections(self): return self.maxConnections
    def set_maxConnections(self, maxConnections): self.maxConnections = maxConnections
    def export(self, outfile, level, namespace_='tns:', name_='connectionThrottle', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='connectionThrottle')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='connectionThrottle'):
        if self.maxConnectionRate is not None and 'maxConnectionRate' not in already_processed:
            already_processed.append('maxConnectionRate')
            outfile.write(' maxConnectionRate="%s"' % self.gds_format_integer(self.maxConnectionRate, input_name='maxConnectionRate'))
        if self.minConnections is not None and 'minConnections' not in already_processed:
            already_processed.append('minConnections')
            outfile.write(' minConnections="%s"' % self.gds_format_integer(self.minConnections, input_name='minConnections'))
        if self.rateInterval is not None and 'rateInterval' not in already_processed:
            already_processed.append('rateInterval')
            outfile.write(' rateInterval="%s"' % self.gds_format_integer(self.rateInterval, input_name='rateInterval'))
        if self.maxConnections is not None and 'maxConnections' not in already_processed:
            already_processed.append('maxConnections')
            outfile.write(' maxConnections="%s"' % self.gds_format_integer(self.maxConnections, input_name='maxConnections'))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='connectionThrottle', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='connectionThrottle'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.maxConnectionRate is not None and 'maxConnectionRate' not in already_processed:
            already_processed.append('maxConnectionRate')
            showIndent(outfile, level)
            outfile.write('maxConnectionRate = %d,\n' % (self.maxConnectionRate,))
        if self.minConnections is not None and 'minConnections' not in already_processed:
            already_processed.append('minConnections')
            showIndent(outfile, level)
            outfile.write('minConnections = %d,\n' % (self.minConnections,))
        if self.rateInterval is not None and 'rateInterval' not in already_processed:
            already_processed.append('rateInterval')
            showIndent(outfile, level)
            outfile.write('rateInterval = %d,\n' % (self.rateInterval,))
        if self.maxConnections is not None and 'maxConnections' not in already_processed:
            already_processed.append('maxConnections')
            showIndent(outfile, level)
            outfile.write('maxConnections = %d,\n' % (self.maxConnections,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('maxConnectionRate', node)
        if value is not None and 'maxConnectionRate' not in already_processed:
            already_processed.append('maxConnectionRate')
            try:
                self.maxConnectionRate = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('minConnections', node)
        if value is not None and 'minConnections' not in already_processed:
            already_processed.append('minConnections')
            try:
                self.minConnections = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('rateInterval', node)
        if value is not None and 'rateInterval' not in already_processed:
            already_processed.append('rateInterval')
            try:
                self.rateInterval = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('maxConnections', node)
        if value is not None and 'maxConnections' not in already_processed:
            already_processed.append('maxConnections')
            try:
                self.maxConnections = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class connectionThrottle


class algorithm(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if algorithm.subclass:
            return algorithm.subclass(*args_, **kwargs_)
        else:
            return algorithm(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='tns:', name_='algorithm', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='algorithm')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='algorithm'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='algorithm', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='algorithm'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class algorithm


class algorithms(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, algorithm=None):
        if algorithm is None:
            self.algorithm = []
        else:
            self.algorithm = algorithm
    def factory(*args_, **kwargs_):
        if algorithms.subclass:
            return algorithms.subclass(*args_, **kwargs_)
        else:
            return algorithms(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_algorithm(self): return self.algorithm
    def set_algorithm(self, algorithm): self.algorithm = algorithm
    def add_algorithm(self, value): self.algorithm.append(value)
    def insert_algorithm(self, index, value): self.algorithm[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='algorithms', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='algorithms')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='algorithms'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='algorithms', fromsubclass_=False):
        for algorithm_ in self.algorithm:
            algorithm_.export(outfile, level, namespace_, name_='algorithm')
    def hasContent_(self):
        if (
            self.algorithm
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='algorithms'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('algorithm=[\n')
        level += 1
        for algorithm_ in self.algorithm:
            showIndent(outfile, level)
            outfile.write('model_.algorithm(\n')
            algorithm_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'algorithm':
            obj_ = algorithm.factory()
            obj_.build(child_)
            self.algorithm.append(obj_)
# end class algorithms


class accessList(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, networkItem=None):
        if networkItem is None:
            self.networkItem = []
        else:
            self.networkItem = networkItem
    def factory(*args_, **kwargs_):
        if accessList.subclass:
            return accessList.subclass(*args_, **kwargs_)
        else:
            return accessList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_networkItem(self): return self.networkItem
    def set_networkItem(self, networkItem): self.networkItem = networkItem
    def add_networkItem(self, value): self.networkItem.append(value)
    def insert_networkItem(self, index, value): self.networkItem[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='accessList', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accessList')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='accessList'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='accessList', fromsubclass_=False):
        for networkItem_ in self.networkItem:
            networkItem_.export(outfile, level, namespace_, name_='networkItem')
    def hasContent_(self):
        if (
            self.networkItem
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='accessList'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('networkItem=[\n')
        level += 1
        for networkItem_ in self.networkItem:
            showIndent(outfile, level)
            outfile.write('model_.networkItem(\n')
            networkItem_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'networkItem':
            obj_ = networkItem.factory()
            obj_.build(child_)
            self.networkItem.append(obj_)
# end class accessList


class networkItem(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ipVersion=None, type_=None, id=None, address=None):
        self.ipVersion = _cast(None, ipVersion)
        self.type_ = _cast(None, type_)
        self.id = _cast(int, id)
        self.address = _cast(None, address)
        pass
    def factory(*args_, **kwargs_):
        if networkItem.subclass:
            return networkItem.subclass(*args_, **kwargs_)
        else:
            return networkItem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ipVersion(self): return self.ipVersion
    def set_ipVersion(self, ipVersion): self.ipVersion = ipVersion
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def export(self, outfile, level, namespace_='tns:', name_='networkItem', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='networkItem')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='networkItem'):
        if self.ipVersion is not None and 'ipVersion' not in already_processed:
            already_processed.append('ipVersion')
            outfile.write(' ipVersion=%s' % (quote_attrib(self.ipVersion), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.address is not None and 'address' not in already_processed:
            already_processed.append('address')
            outfile.write(' address=%s' % (self.gds_format_string(quote_attrib(self.address).encode(ExternalEncoding), input_name='address'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='networkItem', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='networkItem'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ipVersion is not None and 'ipVersion' not in already_processed:
            already_processed.append('ipVersion')
            showIndent(outfile, level)
            outfile.write('ipVersion = %s,\n' % (self.ipVersion,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = %s,\n' % (self.type_,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %d,\n' % (self.id,))
        if self.address is not None and 'address' not in already_processed:
            already_processed.append('address')
            showIndent(outfile, level)
            outfile.write('address = "%s",\n' % (self.address,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ipVersion', node)
        if value is not None and 'ipVersion' not in already_processed:
            already_processed.append('ipVersion')
            self.ipVersion = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            try:
                self.id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('address', node)
        if value is not None and 'address' not in already_processed:
            already_processed.append('address')
            self.address = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class networkItem


class loadBalancerUsageRecord(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, startTime=None, eventType=None, outgoingTransfer=None, incomingTransfer=None, numPolls=None, numVips=None, endTime=None, id=None, vipType=None, averageNumConnections=None):
        self.startTime = _cast(None, startTime)
        self.eventType = _cast(None, eventType)
        self.outgoingTransfer = _cast(int, outgoingTransfer)
        self.incomingTransfer = _cast(int, incomingTransfer)
        self.numPolls = _cast(int, numPolls)
        self.numVips = _cast(int, numVips)
        self.endTime = _cast(None, endTime)
        self.id = _cast(int, id)
        self.vipType = _cast(None, vipType)
        self.averageNumConnections = _cast(float, averageNumConnections)
        pass
    def factory(*args_, **kwargs_):
        if loadBalancerUsageRecord.subclass:
            return loadBalancerUsageRecord.subclass(*args_, **kwargs_)
        else:
            return loadBalancerUsageRecord(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_startTime(self): return self.startTime
    def set_startTime(self, startTime): self.startTime = startTime
    def get_eventType(self): return self.eventType
    def set_eventType(self, eventType): self.eventType = eventType
    def get_outgoingTransfer(self): return self.outgoingTransfer
    def set_outgoingTransfer(self, outgoingTransfer): self.outgoingTransfer = outgoingTransfer
    def get_incomingTransfer(self): return self.incomingTransfer
    def set_incomingTransfer(self, incomingTransfer): self.incomingTransfer = incomingTransfer
    def get_numPolls(self): return self.numPolls
    def set_numPolls(self, numPolls): self.numPolls = numPolls
    def get_numVips(self): return self.numVips
    def set_numVips(self, numVips): self.numVips = numVips
    def get_endTime(self): return self.endTime
    def set_endTime(self, endTime): self.endTime = endTime
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_vipType(self): return self.vipType
    def set_vipType(self, vipType): self.vipType = vipType
    def get_averageNumConnections(self): return self.averageNumConnections
    def set_averageNumConnections(self, averageNumConnections): self.averageNumConnections = averageNumConnections
    def export(self, outfile, level, namespace_='tns:', name_='loadBalancerUsageRecord', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='loadBalancerUsageRecord')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='loadBalancerUsageRecord'):
        if self.startTime is not None and 'startTime' not in already_processed:
            already_processed.append('startTime')
            outfile.write(' startTime=%s' % (self.gds_format_string(quote_attrib(self.startTime).encode(ExternalEncoding), input_name='startTime'), ))
        if self.eventType is not None and 'eventType' not in already_processed:
            already_processed.append('eventType')
            outfile.write(' eventType=%s' % (self.gds_format_string(quote_attrib(self.eventType).encode(ExternalEncoding), input_name='eventType'), ))
        if self.outgoingTransfer is not None and 'outgoingTransfer' not in already_processed:
            already_processed.append('outgoingTransfer')
            outfile.write(' outgoingTransfer="%s"' % self.gds_format_integer(self.outgoingTransfer, input_name='outgoingTransfer'))
        if self.incomingTransfer is not None and 'incomingTransfer' not in already_processed:
            already_processed.append('incomingTransfer')
            outfile.write(' incomingTransfer="%s"' % self.gds_format_integer(self.incomingTransfer, input_name='incomingTransfer'))
        if self.numPolls is not None and 'numPolls' not in already_processed:
            already_processed.append('numPolls')
            outfile.write(' numPolls="%s"' % self.gds_format_integer(self.numPolls, input_name='numPolls'))
        if self.numVips is not None and 'numVips' not in already_processed:
            already_processed.append('numVips')
            outfile.write(' numVips="%s"' % self.gds_format_integer(self.numVips, input_name='numVips'))
        if self.endTime is not None and 'endTime' not in already_processed:
            already_processed.append('endTime')
            outfile.write(' endTime=%s' % (self.gds_format_string(quote_attrib(self.endTime).encode(ExternalEncoding), input_name='endTime'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.vipType is not None and 'vipType' not in already_processed:
            already_processed.append('vipType')
            outfile.write(' vipType=%s' % (quote_attrib(self.vipType), ))
        if self.averageNumConnections is not None and 'averageNumConnections' not in already_processed:
            already_processed.append('averageNumConnections')
            outfile.write(' averageNumConnections="%s"' % self.gds_format_double(self.averageNumConnections, input_name='averageNumConnections'))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='loadBalancerUsageRecord', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='loadBalancerUsageRecord'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.startTime is not None and 'startTime' not in already_processed:
            already_processed.append('startTime')
            showIndent(outfile, level)
            outfile.write('startTime = "%s",\n' % (self.startTime,))
        if self.eventType is not None and 'eventType' not in already_processed:
            already_processed.append('eventType')
            showIndent(outfile, level)
            outfile.write('eventType = "%s",\n' % (self.eventType,))
        if self.outgoingTransfer is not None and 'outgoingTransfer' not in already_processed:
            already_processed.append('outgoingTransfer')
            showIndent(outfile, level)
            outfile.write('outgoingTransfer = %d,\n' % (self.outgoingTransfer,))
        if self.incomingTransfer is not None and 'incomingTransfer' not in already_processed:
            already_processed.append('incomingTransfer')
            showIndent(outfile, level)
            outfile.write('incomingTransfer = %d,\n' % (self.incomingTransfer,))
        if self.numPolls is not None and 'numPolls' not in already_processed:
            already_processed.append('numPolls')
            showIndent(outfile, level)
            outfile.write('numPolls = %d,\n' % (self.numPolls,))
        if self.numVips is not None and 'numVips' not in already_processed:
            already_processed.append('numVips')
            showIndent(outfile, level)
            outfile.write('numVips = %d,\n' % (self.numVips,))
        if self.endTime is not None and 'endTime' not in already_processed:
            already_processed.append('endTime')
            showIndent(outfile, level)
            outfile.write('endTime = "%s",\n' % (self.endTime,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %d,\n' % (self.id,))
        if self.vipType is not None and 'vipType' not in already_processed:
            already_processed.append('vipType')
            showIndent(outfile, level)
            outfile.write('vipType = %s,\n' % (self.vipType,))
        if self.averageNumConnections is not None and 'averageNumConnections' not in already_processed:
            already_processed.append('averageNumConnections')
            showIndent(outfile, level)
            outfile.write('averageNumConnections = %e,\n' % (self.averageNumConnections,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('startTime', node)
        if value is not None and 'startTime' not in already_processed:
            already_processed.append('startTime')
            self.startTime = value
        value = find_attr_value_('eventType', node)
        if value is not None and 'eventType' not in already_processed:
            already_processed.append('eventType')
            self.eventType = value
        value = find_attr_value_('outgoingTransfer', node)
        if value is not None and 'outgoingTransfer' not in already_processed:
            already_processed.append('outgoingTransfer')
            try:
                self.outgoingTransfer = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('incomingTransfer', node)
        if value is not None and 'incomingTransfer' not in already_processed:
            already_processed.append('incomingTransfer')
            try:
                self.incomingTransfer = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numPolls', node)
        if value is not None and 'numPolls' not in already_processed:
            already_processed.append('numPolls')
            try:
                self.numPolls = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numVips', node)
        if value is not None and 'numVips' not in already_processed:
            already_processed.append('numVips')
            try:
                self.numVips = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('endTime', node)
        if value is not None and 'endTime' not in already_processed:
            already_processed.append('endTime')
            self.endTime = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            try:
                self.id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('vipType', node)
        if value is not None and 'vipType' not in already_processed:
            already_processed.append('vipType')
            self.vipType = value
        value = find_attr_value_('averageNumConnections', node)
        if value is not None and 'averageNumConnections' not in already_processed:
            already_processed.append('averageNumConnections')
            try:
                self.averageNumConnections = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (averageNumConnections): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class loadBalancerUsageRecord


class accountBilling(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, accountId=None, accountUsage=None, loadBalancerUsage=None):
        self.accountId = _cast(int, accountId)
        self.accountUsage = accountUsage
        if loadBalancerUsage is None:
            self.loadBalancerUsage = []
        else:
            self.loadBalancerUsage = loadBalancerUsage
    def factory(*args_, **kwargs_):
        if accountBilling.subclass:
            return accountBilling.subclass(*args_, **kwargs_)
        else:
            return accountBilling(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accountUsage(self): return self.accountUsage
    def set_accountUsage(self, accountUsage): self.accountUsage = accountUsage
    def get_loadBalancerUsage(self): return self.loadBalancerUsage
    def set_loadBalancerUsage(self, loadBalancerUsage): self.loadBalancerUsage = loadBalancerUsage
    def add_loadBalancerUsage(self, value): self.loadBalancerUsage.append(value)
    def insert_loadBalancerUsage(self, index, value): self.loadBalancerUsage[index] = value
    def get_accountId(self): return self.accountId
    def set_accountId(self, accountId): self.accountId = accountId
    def export(self, outfile, level, namespace_='tns:', name_='accountBilling', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accountBilling')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='accountBilling'):
        if self.accountId is not None and 'accountId' not in already_processed:
            already_processed.append('accountId')
            outfile.write(' accountId="%s"' % self.gds_format_integer(self.accountId, input_name='accountId'))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='accountBilling', fromsubclass_=False):
        if self.accountUsage is not None:
            self.accountUsage.export(outfile, level, namespace_, name_='accountUsage')
        for loadBalancerUsage_ in self.loadBalancerUsage:
            loadBalancerUsage_.export(outfile, level, namespace_, name_='loadBalancerUsage')
    def hasContent_(self):
        if (
            self.accountUsage is not None or
            self.loadBalancerUsage
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='accountBilling'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.accountId is not None and 'accountId' not in already_processed:
            already_processed.append('accountId')
            showIndent(outfile, level)
            outfile.write('accountId = %d,\n' % (self.accountId,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.accountUsage is not None:
            showIndent(outfile, level)
            outfile.write('accountUsage=model_.accountUsage(\n')
            self.accountUsage.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('loadBalancerUsage=[\n')
        level += 1
        for loadBalancerUsage_ in self.loadBalancerUsage:
            showIndent(outfile, level)
            outfile.write('model_.loadBalancerUsage(\n')
            loadBalancerUsage_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accountId', node)
        if value is not None and 'accountId' not in already_processed:
            already_processed.append('accountId')
            try:
                self.accountId = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accountUsage':
            obj_ = accountUsage.factory()
            obj_.build(child_)
            self.set_accountUsage(obj_)
        elif nodeName_ == 'loadBalancerUsage':
            obj_ = loadBalancerUsage.factory()
            obj_.build(child_)
            self.loadBalancerUsage.append(obj_)
# end class accountBilling


class accountUsage(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, accountUsageRecord=None, link=None):
        if accountUsageRecord is None:
            self.accountUsageRecord = []
        else:
            self.accountUsageRecord = accountUsageRecord
        if link is None:
            self.link = []
        else:
            self.link = link
    def factory(*args_, **kwargs_):
        if accountUsage.subclass:
            return accountUsage.subclass(*args_, **kwargs_)
        else:
            return accountUsage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accountUsageRecord(self): return self.accountUsageRecord
    def set_accountUsageRecord(self, accountUsageRecord): self.accountUsageRecord = accountUsageRecord
    def add_accountUsageRecord(self, value): self.accountUsageRecord.append(value)
    def insert_accountUsageRecord(self, index, value): self.accountUsageRecord[index] = value
    def get_link(self): return self.link
    def set_link(self, link): self.link = link
    def add_link(self, value): self.link.append(value)
    def insert_link(self, index, value): self.link[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='accountUsage', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accountUsage')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='accountUsage'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='accountUsage', fromsubclass_=False):
        for accountUsageRecord_ in self.accountUsageRecord:
            accountUsageRecord_.export(outfile, level, namespace_, name_='accountUsageRecord')
        for link_ in self.link:
            link_.export(outfile, level, namespace_, name_='link')
    def hasContent_(self):
        if (
            self.accountUsageRecord or
            self.link
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='accountUsage'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('accountUsageRecord=[\n')
        level += 1
        for accountUsageRecord_ in self.accountUsageRecord:
            showIndent(outfile, level)
            outfile.write('model_.accountUsageRecord(\n')
            accountUsageRecord_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('link=[\n')
        level += 1
        for link_ in self.link:
            showIndent(outfile, level)
            outfile.write('model_.link(\n')
            link_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accountUsageRecord':
            obj_ = accountUsageRecord.factory()
            obj_.build(child_)
            self.accountUsageRecord.append(obj_)
        elif nodeName_ == 'link':
            obj_ = linkType.factory()
            obj_.build(child_)
            self.link.append(obj_)
# end class accountUsage


class accountUsageRecord(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, numPublicVips=None, numServicenetVips=None, numLoadBalancers=None, startTime=None):
        self.numPublicVips = _cast(int, numPublicVips)
        self.numServicenetVips = _cast(int, numServicenetVips)
        self.numLoadBalancers = _cast(int, numLoadBalancers)
        self.startTime = _cast(None, startTime)
        pass
    def factory(*args_, **kwargs_):
        if accountUsageRecord.subclass:
            return accountUsageRecord.subclass(*args_, **kwargs_)
        else:
            return accountUsageRecord(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_numPublicVips(self): return self.numPublicVips
    def set_numPublicVips(self, numPublicVips): self.numPublicVips = numPublicVips
    def get_numServicenetVips(self): return self.numServicenetVips
    def set_numServicenetVips(self, numServicenetVips): self.numServicenetVips = numServicenetVips
    def get_numLoadBalancers(self): return self.numLoadBalancers
    def set_numLoadBalancers(self, numLoadBalancers): self.numLoadBalancers = numLoadBalancers
    def get_startTime(self): return self.startTime
    def set_startTime(self, startTime): self.startTime = startTime
    def export(self, outfile, level, namespace_='tns:', name_='accountUsageRecord', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='accountUsageRecord')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='accountUsageRecord'):
        if self.numPublicVips is not None and 'numPublicVips' not in already_processed:
            already_processed.append('numPublicVips')
            outfile.write(' numPublicVips="%s"' % self.gds_format_integer(self.numPublicVips, input_name='numPublicVips'))
        if self.numServicenetVips is not None and 'numServicenetVips' not in already_processed:
            already_processed.append('numServicenetVips')
            outfile.write(' numServicenetVips="%s"' % self.gds_format_integer(self.numServicenetVips, input_name='numServicenetVips'))
        if self.numLoadBalancers is not None and 'numLoadBalancers' not in already_processed:
            already_processed.append('numLoadBalancers')
            outfile.write(' numLoadBalancers="%s"' % self.gds_format_integer(self.numLoadBalancers, input_name='numLoadBalancers'))
        if self.startTime is not None and 'startTime' not in already_processed:
            already_processed.append('startTime')
            outfile.write(' startTime=%s' % (self.gds_format_string(quote_attrib(self.startTime).encode(ExternalEncoding), input_name='startTime'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='accountUsageRecord', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='accountUsageRecord'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.numPublicVips is not None and 'numPublicVips' not in already_processed:
            already_processed.append('numPublicVips')
            showIndent(outfile, level)
            outfile.write('numPublicVips = %d,\n' % (self.numPublicVips,))
        if self.numServicenetVips is not None and 'numServicenetVips' not in already_processed:
            already_processed.append('numServicenetVips')
            showIndent(outfile, level)
            outfile.write('numServicenetVips = %d,\n' % (self.numServicenetVips,))
        if self.numLoadBalancers is not None and 'numLoadBalancers' not in already_processed:
            already_processed.append('numLoadBalancers')
            showIndent(outfile, level)
            outfile.write('numLoadBalancers = %d,\n' % (self.numLoadBalancers,))
        if self.startTime is not None and 'startTime' not in already_processed:
            already_processed.append('startTime')
            showIndent(outfile, level)
            outfile.write('startTime = "%s",\n' % (self.startTime,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numPublicVips', node)
        if value is not None and 'numPublicVips' not in already_processed:
            already_processed.append('numPublicVips')
            try:
                self.numPublicVips = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numServicenetVips', node)
        if value is not None and 'numServicenetVips' not in already_processed:
            already_processed.append('numServicenetVips')
            try:
                self.numServicenetVips = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('numLoadBalancers', node)
        if value is not None and 'numLoadBalancers' not in already_processed:
            already_processed.append('numLoadBalancers')
            try:
                self.numLoadBalancers = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('startTime', node)
        if value is not None and 'startTime' not in already_processed:
            already_processed.append('startTime')
            self.startTime = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class accountUsageRecord


class loadBalancerUsage(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, loadBalancerName=None, loadBalancerId=None, loadBalancerUsageRecord=None, link=None):
        self.loadBalancerName = _cast(None, loadBalancerName)
        self.loadBalancerId = _cast(int, loadBalancerId)
        if loadBalancerUsageRecord is None:
            self.loadBalancerUsageRecord = []
        else:
            self.loadBalancerUsageRecord = loadBalancerUsageRecord
        if link is None:
            self.link = []
        else:
            self.link = link
    def factory(*args_, **kwargs_):
        if loadBalancerUsage.subclass:
            return loadBalancerUsage.subclass(*args_, **kwargs_)
        else:
            return loadBalancerUsage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_loadBalancerUsageRecord(self): return self.loadBalancerUsageRecord
    def set_loadBalancerUsageRecord(self, loadBalancerUsageRecord): self.loadBalancerUsageRecord = loadBalancerUsageRecord
    def add_loadBalancerUsageRecord(self, value): self.loadBalancerUsageRecord.append(value)
    def insert_loadBalancerUsageRecord(self, index, value): self.loadBalancerUsageRecord[index] = value
    def get_link(self): return self.link
    def set_link(self, link): self.link = link
    def add_link(self, value): self.link.append(value)
    def insert_link(self, index, value): self.link[index] = value
    def get_loadBalancerName(self): return self.loadBalancerName
    def set_loadBalancerName(self, loadBalancerName): self.loadBalancerName = loadBalancerName
    def get_loadBalancerId(self): return self.loadBalancerId
    def set_loadBalancerId(self, loadBalancerId): self.loadBalancerId = loadBalancerId
    def export(self, outfile, level, namespace_='tns:', name_='loadBalancerUsage', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='loadBalancerUsage')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='loadBalancerUsage'):
        if self.loadBalancerName is not None and 'loadBalancerName' not in already_processed:
            already_processed.append('loadBalancerName')
            outfile.write(' loadBalancerName=%s' % (self.gds_format_string(quote_attrib(self.loadBalancerName).encode(ExternalEncoding), input_name='loadBalancerName'), ))
        if self.loadBalancerId is not None and 'loadBalancerId' not in already_processed:
            already_processed.append('loadBalancerId')
            outfile.write(' loadBalancerId="%s"' % self.gds_format_integer(self.loadBalancerId, input_name='loadBalancerId'))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='loadBalancerUsage', fromsubclass_=False):
        for loadBalancerUsageRecord_ in self.loadBalancerUsageRecord:
            loadBalancerUsageRecord_.export(outfile, level, namespace_, name_='loadBalancerUsageRecord')
        for link_ in self.link:
            link_.export(outfile, level, namespace_, name_='link')
    def hasContent_(self):
        if (
            self.loadBalancerUsageRecord or
            self.link
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='loadBalancerUsage'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.loadBalancerName is not None and 'loadBalancerName' not in already_processed:
            already_processed.append('loadBalancerName')
            showIndent(outfile, level)
            outfile.write('loadBalancerName = "%s",\n' % (self.loadBalancerName,))
        if self.loadBalancerId is not None and 'loadBalancerId' not in already_processed:
            already_processed.append('loadBalancerId')
            showIndent(outfile, level)
            outfile.write('loadBalancerId = %d,\n' % (self.loadBalancerId,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('loadBalancerUsageRecord=[\n')
        level += 1
        for loadBalancerUsageRecord_ in self.loadBalancerUsageRecord:
            showIndent(outfile, level)
            outfile.write('model_.loadBalancerUsageRecord(\n')
            loadBalancerUsageRecord_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('link=[\n')
        level += 1
        for link_ in self.link:
            showIndent(outfile, level)
            outfile.write('model_.link(\n')
            link_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('loadBalancerName', node)
        if value is not None and 'loadBalancerName' not in already_processed:
            already_processed.append('loadBalancerName')
            self.loadBalancerName = value
        value = find_attr_value_('loadBalancerId', node)
        if value is not None and 'loadBalancerId' not in already_processed:
            already_processed.append('loadBalancerId')
            try:
                self.loadBalancerId = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'loadBalancerUsageRecord':
            obj_ = loadBalancerUsageRecord.factory()
            obj_.build(child_)
            self.loadBalancerUsageRecord.append(obj_)
        elif nodeName_ == 'link':
            obj_ = linkType.factory()
            obj_.build(child_)
            self.link.append(obj_)
# end class loadBalancerUsage


class cluster(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if cluster.subclass:
            return cluster.subclass(*args_, **kwargs_)
        else:
            return cluster(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='tns:', name_='cluster', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='cluster')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='cluster'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='cluster', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cluster'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class cluster


class protocols(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, protocol=None):
        if protocol is None:
            self.protocol = []
        else:
            self.protocol = protocol
    def factory(*args_, **kwargs_):
        if protocols.subclass:
            return protocols.subclass(*args_, **kwargs_)
        else:
            return protocols(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_protocol(self): return self.protocol
    def set_protocol(self, protocol): self.protocol = protocol
    def add_protocol(self, value): self.protocol.append(value)
    def insert_protocol(self, index, value): self.protocol[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='protocols', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='protocols')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='protocols'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='protocols', fromsubclass_=False):
        for protocol_ in self.protocol:
            protocol_.export(outfile, level, namespace_, name_='protocol')
    def hasContent_(self):
        if (
            self.protocol
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='protocols'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('protocol=[\n')
        level += 1
        for protocol_ in self.protocol:
            showIndent(outfile, level)
            outfile.write('model_.protocol(\n')
            protocol_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'protocol':
            obj_ = protocol.factory()
            obj_.build(child_)
            self.protocol.append(obj_)
# end class protocols


class operationresponse(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, status=None, message=None):
        self.status = _cast(int, status)
        self.message = _cast(None, message)
        pass
    def factory(*args_, **kwargs_):
        if operationresponse.subclass:
            return operationresponse.subclass(*args_, **kwargs_)
        else:
            return operationresponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_message(self): return self.message
    def set_message(self, message): self.message = message
    def export(self, outfile, level, namespace_='tns:', name_='operationresponse', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='operationresponse')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='operationresponse'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            outfile.write(' status="%s"' % self.gds_format_integer(self.status, input_name='status'))
        if self.message is not None and 'message' not in already_processed:
            already_processed.append('message')
            outfile.write(' message=%s' % (self.gds_format_string(quote_attrib(self.message).encode(ExternalEncoding), input_name='message'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='operationresponse', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='operationresponse'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.append('status')
            showIndent(outfile, level)
            outfile.write('status = %d,\n' % (self.status,))
        if self.message is not None and 'message' not in already_processed:
            already_processed.append('message')
            showIndent(outfile, level)
            outfile.write('message = "%s",\n' % (self.message,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.append('status')
            try:
                self.status = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('message', node)
        if value is not None and 'message' not in already_processed:
            already_processed.append('message')
            self.message = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class operationresponse


class protocol(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, port=None):
        self.name = _cast(None, name)
        self.port = _cast(int, port)
        pass
    def factory(*args_, **kwargs_):
        if protocol.subclass:
            return protocol.subclass(*args_, **kwargs_)
        else:
            return protocol(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_port(self): return self.port
    def set_port(self, port): self.port = port
    def export(self, outfile, level, namespace_='tns:', name_='protocol', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='protocol')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='protocol'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.port is not None and 'port' not in already_processed:
            already_processed.append('port')
            outfile.write(' port="%s"' % self.gds_format_integer(self.port, input_name='port'))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='protocol', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='protocol'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.port is not None and 'port' not in already_processed:
            already_processed.append('port')
            showIndent(outfile, level)
            outfile.write('port = %d,\n' % (self.port,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('port', node)
        if value is not None and 'port' not in already_processed:
            already_processed.append('port')
            try:
                self.port = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class protocol


class limitTypes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, limitType=None):
        if limitType is None:
            self.limitType = []
        else:
            self.limitType = limitType
    def factory(*args_, **kwargs_):
        if limitTypes.subclass:
            return limitTypes.subclass(*args_, **kwargs_)
        else:
            return limitTypes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_limitType(self): return self.limitType
    def set_limitType(self, limitType): self.limitType = limitType
    def add_limitType(self, value): self.limitType.append(value)
    def insert_limitType(self, index, value): self.limitType[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='limitTypes', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='limitTypes')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='limitTypes'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='limitTypes', fromsubclass_=False):
        for limitType_ in self.limitType:
            limitType_.export(outfile, level, namespace_, name_='limitType')
    def hasContent_(self):
        if (
            self.limitType
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='limitTypes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('limitType=[\n')
        level += 1
        for limitType_ in self.limitType:
            showIndent(outfile, level)
            outfile.write('model_.limitType(\n')
            limitType_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'limitType':
            obj_ = limitType.factory()
            obj_.build(child_)
            self.limitType.append(obj_)
# end class limitTypes


class limitType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, defaultValue=None, name=None, description=None):
        self.defaultValue = _cast(int, defaultValue)
        self.name = _cast(None, name)
        self.description = _cast(None, description)
        pass
    def factory(*args_, **kwargs_):
        if limitType.subclass:
            return limitType.subclass(*args_, **kwargs_)
        else:
            return limitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_defaultValue(self): return self.defaultValue
    def set_defaultValue(self, defaultValue): self.defaultValue = defaultValue
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def export(self, outfile, level, namespace_='tns:', name_='limitType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='limitType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='limitType'):
        if self.defaultValue is not None and 'defaultValue' not in already_processed:
            already_processed.append('defaultValue')
            outfile.write(' defaultValue="%s"' % self.gds_format_integer(self.defaultValue, input_name='defaultValue'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='limitType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='limitType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.defaultValue is not None and 'defaultValue' not in already_processed:
            already_processed.append('defaultValue')
            showIndent(outfile, level)
            outfile.write('defaultValue = %d,\n' % (self.defaultValue,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.description is not None and 'description' not in already_processed:
            already_processed.append('description')
            showIndent(outfile, level)
            outfile.write('description = "%s",\n' % (self.description,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('defaultValue', node)
        if value is not None and 'defaultValue' not in already_processed:
            already_processed.append('defaultValue')
            try:
                self.defaultValue = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.append('description')
            self.description = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class limitType


class limits(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, absolute=None):
        self.absolute = absolute
    def factory(*args_, **kwargs_):
        if limits.subclass:
            return limits.subclass(*args_, **kwargs_)
        else:
            return limits(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_absolute(self): return self.absolute
    def set_absolute(self, absolute): self.absolute = absolute
    def export(self, outfile, level, namespace_='tns:', name_='limits', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='limits')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='limits'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='limits', fromsubclass_=False):
        if self.absolute is not None:
            self.absolute.export(outfile, level, namespace_, name_='absolute', )
    def hasContent_(self):
        if (
            self.absolute is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='limits'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.absolute is not None:
            showIndent(outfile, level)
            outfile.write('absolute=model_.absolute(\n')
            self.absolute.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'absolute':
            obj_ = absolute.factory()
            obj_.build(child_)
            self.set_absolute(obj_)
# end class limits


class absolute(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, limit=None):
        if limit is None:
            self.limit = []
        else:
            self.limit = limit
    def factory(*args_, **kwargs_):
        if absolute.subclass:
            return absolute.subclass(*args_, **kwargs_)
        else:
            return absolute(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_limit(self): return self.limit
    def set_limit(self, limit): self.limit = limit
    def add_limit(self, value): self.limit.append(value)
    def insert_limit(self, index, value): self.limit[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='absolute', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='absolute')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='absolute'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='absolute', fromsubclass_=False):
        for limit_ in self.limit:
            limit_.export(outfile, level, namespace_, name_='limit')
    def hasContent_(self):
        if (
            self.limit
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='absolute'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('limit=[\n')
        level += 1
        for limit_ in self.limit:
            showIndent(outfile, level)
            outfile.write('model_.limit(\n')
            limit_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'limit':
            obj_ = limit.factory()
            obj_.build(child_)
            self.limit.append(obj_)
# end class absolute


class limit(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, value=None, name=None):
        self.id = _cast(int, id)
        self.value = _cast(int, value)
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if limit.subclass:
            return limit.subclass(*args_, **kwargs_)
        else:
            return limit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='tns:', name_='limit', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='limit')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='limit'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value="%s"' % self.gds_format_integer(self.value, input_name='value'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='limit', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='limit'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %d,\n' % (self.id,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = %d,\n' % (self.value,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            try:
                self.id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            try:
                self.value = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class limit


class errorpage(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, content=None):
        self.content = content
    def factory(*args_, **kwargs_):
        if errorpage.subclass:
            return errorpage.subclass(*args_, **kwargs_)
        else:
            return errorpage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def export(self, outfile, level, namespace_='tns:', name_='errorpage', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='errorpage')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='errorpage'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='errorpage', fromsubclass_=False):
        if self.content is not None:
            showIndent(outfile, level)
            outfile.write('<%scontent>%s</%scontent>\n' % (namespace_, self.gds_format_string(quote_xml(self.content).encode(ExternalEncoding), input_name='content'), namespace_))
    def hasContent_(self):
        if (
            self.content is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='errorpage'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.content is not None:
            showIndent(outfile, level)
            outfile.write('content=%s,\n' % quote_python(self.content).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'content':
            content_ = child_.text
            content_ = self.gds_validate_string(content_, node, 'content')
            self.content = content_
# end class errorpage


class sslTermination(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, securePort=None, enabled=None, id=None, secureTrafficOnly=None, privatekey=None, certificate=None, intermediateCertificate=None):
        self.securePort = _cast(int, securePort)
        self.enabled = _cast(bool, enabled)
        self.id = _cast(int, id)
        self.secureTrafficOnly = _cast(bool, secureTrafficOnly)
        self.privatekey = privatekey
        self.certificate = certificate
        self.intermediateCertificate = intermediateCertificate
    def factory(*args_, **kwargs_):
        if sslTermination.subclass:
            return sslTermination.subclass(*args_, **kwargs_)
        else:
            return sslTermination(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_privatekey(self): return self.privatekey
    def set_privatekey(self, privatekey): self.privatekey = privatekey
    def get_certificate(self): return self.certificate
    def set_certificate(self, certificate): self.certificate = certificate
    def get_intermediateCertificate(self): return self.intermediateCertificate
    def set_intermediateCertificate(self, intermediateCertificate): self.intermediateCertificate = intermediateCertificate
    def get_securePort(self): return self.securePort
    def set_securePort(self, securePort): self.securePort = securePort
    def get_enabled(self): return self.enabled
    def set_enabled(self, enabled): self.enabled = enabled
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_secureTrafficOnly(self): return self.secureTrafficOnly
    def set_secureTrafficOnly(self, secureTrafficOnly): self.secureTrafficOnly = secureTrafficOnly
    def export(self, outfile, level, namespace_='tns:', name_='sslTermination', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sslTermination')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='sslTermination'):
        if self.securePort is not None and 'securePort' not in already_processed:
            already_processed.append('securePort')
            outfile.write(' securePort="%s"' % self.gds_format_integer(self.securePort, input_name='securePort'))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.append('enabled')
            outfile.write(' enabled="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.enabled)), input_name='enabled'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.secureTrafficOnly is not None and 'secureTrafficOnly' not in already_processed:
            already_processed.append('secureTrafficOnly')
            outfile.write(' secureTrafficOnly="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.secureTrafficOnly)), input_name='secureTrafficOnly'))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='sslTermination', fromsubclass_=False):
        if self.privatekey is not None:
            showIndent(outfile, level)
            outfile.write('<%sprivatekey>%s</%sprivatekey>\n' % (namespace_, self.gds_format_string(quote_xml(self.privatekey).encode(ExternalEncoding), input_name='privatekey'), namespace_))
        if self.certificate is not None:
            showIndent(outfile, level)
            outfile.write('<%scertificate>%s</%scertificate>\n' % (namespace_, self.gds_format_string(quote_xml(self.certificate).encode(ExternalEncoding), input_name='certificate'), namespace_))
        if self.intermediateCertificate is not None:
            showIndent(outfile, level)
            outfile.write('<%sintermediateCertificate>%s</%sintermediateCertificate>\n' % (namespace_, self.gds_format_string(quote_xml(self.intermediateCertificate).encode(ExternalEncoding), input_name='intermediateCertificate'), namespace_))
    def hasContent_(self):
        if (
            self.privatekey is not None or
            self.certificate is not None or
            self.intermediateCertificate is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sslTermination'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.securePort is not None and 'securePort' not in already_processed:
            already_processed.append('securePort')
            showIndent(outfile, level)
            outfile.write('securePort = %d,\n' % (self.securePort,))
        if self.enabled is not None and 'enabled' not in already_processed:
            already_processed.append('enabled')
            showIndent(outfile, level)
            outfile.write('enabled = %s,\n' % (self.enabled,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %d,\n' % (self.id,))
        if self.secureTrafficOnly is not None and 'secureTrafficOnly' not in already_processed:
            already_processed.append('secureTrafficOnly')
            showIndent(outfile, level)
            outfile.write('secureTrafficOnly = %s,\n' % (self.secureTrafficOnly,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.privatekey is not None:
            showIndent(outfile, level)
            outfile.write('privatekey=%s,\n' % quote_python(self.privatekey).encode(ExternalEncoding))
        if self.certificate is not None:
            showIndent(outfile, level)
            outfile.write('certificate=%s,\n' % quote_python(self.certificate).encode(ExternalEncoding))
        if self.intermediateCertificate is not None:
            showIndent(outfile, level)
            outfile.write('intermediateCertificate=%s,\n' % quote_python(self.intermediateCertificate).encode(ExternalEncoding))
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('securePort', node)
        if value is not None and 'securePort' not in already_processed:
            already_processed.append('securePort')
            try:
                self.securePort = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('enabled', node)
        if value is not None and 'enabled' not in already_processed:
            already_processed.append('enabled')
            if value in ('true', '1'):
                self.enabled = True
            elif value in ('false', '0'):
                self.enabled = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            try:
                self.id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('secureTrafficOnly', node)
        if value is not None and 'secureTrafficOnly' not in already_processed:
            already_processed.append('secureTrafficOnly')
            if value in ('true', '1'):
                self.secureTrafficOnly = True
            elif value in ('false', '0'):
                self.secureTrafficOnly = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'privatekey':
            privatekey_ = child_.text
            privatekey_ = self.gds_validate_string(privatekey_, node, 'privatekey')
            self.privatekey = privatekey_
        elif nodeName_ == 'certificate':
            certificate_ = child_.text
            certificate_ = self.gds_validate_string(certificate_, node, 'certificate')
            self.certificate = certificate_
        elif nodeName_ == 'intermediateCertificate':
            intermediateCertificate_ = child_.text
            intermediateCertificate_ = self.gds_validate_string(intermediateCertificate_, node, 'intermediateCertificate')
            self.intermediateCertificate = intermediateCertificate_
# end class sslTermination


class allowedDomains(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, allowedDomain=None):
        if allowedDomain is None:
            self.allowedDomain = []
        else:
            self.allowedDomain = allowedDomain
    def factory(*args_, **kwargs_):
        if allowedDomains.subclass:
            return allowedDomains.subclass(*args_, **kwargs_)
        else:
            return allowedDomains(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_allowedDomain(self): return self.allowedDomain
    def set_allowedDomain(self, allowedDomain): self.allowedDomain = allowedDomain
    def add_allowedDomain(self, value): self.allowedDomain.append(value)
    def insert_allowedDomain(self, index, value): self.allowedDomain[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='allowedDomains', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='allowedDomains')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='allowedDomains'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='allowedDomains', fromsubclass_=False):
        for allowedDomain_ in self.allowedDomain:
            allowedDomain_.export(outfile, level, namespace_, name_='allowedDomain')
    def hasContent_(self):
        if (
            self.allowedDomain
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='allowedDomains'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('allowedDomain=[\n')
        level += 1
        for allowedDomain_ in self.allowedDomain:
            showIndent(outfile, level)
            outfile.write('model_.allowedDomain(\n')
            allowedDomain_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'allowedDomain':
            obj_ = allowedDomain.factory()
            obj_.build(child_)
            self.allowedDomain.append(obj_)
# end class allowedDomains


class allowedDomain(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None):
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if allowedDomain.subclass:
            return allowedDomain.subclass(*args_, **kwargs_)
        else:
            return allowedDomain(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def export(self, outfile, level, namespace_='tns:', name_='allowedDomain', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='allowedDomain')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='allowedDomain'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='allowedDomain', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='allowedDomain'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class allowedDomain


class metadata(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, meta=None):
        if meta is None:
            self.meta = []
        else:
            self.meta = meta
    def factory(*args_, **kwargs_):
        if metadata.subclass:
            return metadata.subclass(*args_, **kwargs_)
        else:
            return metadata(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_meta(self): return self.meta
    def set_meta(self, meta): self.meta = meta
    def add_meta(self, value): self.meta.append(value)
    def insert_meta(self, index, value): self.meta[index] = value
    def export(self, outfile, level, namespace_='tns:', name_='metadata', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='metadata')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='metadata'):
        pass
    def exportChildren(self, outfile, level, namespace_='tns:', name_='metadata', fromsubclass_=False):
        for meta_ in self.meta:
            meta_.export(outfile, level, namespace_, name_='meta')
    def hasContent_(self):
        if (
            self.meta
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='metadata'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('meta=[\n')
        level += 1
        for meta_ in self.meta:
            showIndent(outfile, level)
            outfile.write('model_.meta(\n')
            meta_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'meta':
            obj_ = meta.factory()
            obj_.build(child_)
            self.meta.append(obj_)
# end class metadata


class meta(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, key=None, valueOf_=None):
        self.id = _cast(int, id)
        self.key = _cast(None, key)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if meta.subclass:
            return meta.subclass(*args_, **kwargs_)
        else:
            return meta(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='tns:', name_='meta', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='meta')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='meta'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            outfile.write(' id="%s"' % self.gds_format_integer(self.id, input_name='id'))
        if self.key is not None and 'key' not in already_processed:
            already_processed.append('key')
            outfile.write(' key=%s' % (self.gds_format_string(quote_attrib(self.key).encode(ExternalEncoding), input_name='key'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='meta', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='meta'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.append('id')
            showIndent(outfile, level)
            outfile.write('id = %d,\n' % (self.id,))
        if self.key is not None and 'key' not in already_processed:
            already_processed.append('key')
            showIndent(outfile, level)
            outfile.write('key = "%s",\n' % (self.key,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.append('id')
            try:
                self.id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('key', node)
        if value is not None and 'key' not in already_processed:
            already_processed.append('key')
            self.key = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class meta


class textType(GeneratedsSuper):
    """The Atom text construct is defined in section 3.1 of the format
    spec."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, base=None, type_=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.lang = _cast(None, lang)
        self.base = _cast(None, base)
        self.type_ = _cast(None, type_)
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if textType.subclass:
            return textType.subclass(*args_, **kwargs_)
        else:
            return textType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_base(self): return self.base
    def set_base(self, base): self.base = base
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='tns:', name_='textType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='textType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='textType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            outfile.write(' base=%s' % (self.gds_format_string(quote_attrib(self.base).encode(ExternalEncoding), input_name='base'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='textType', fromsubclass_=False):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None or
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='textType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            showIndent(outfile, level)
            outfile.write('base = "%s",\n' % (self.base,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            self.lang = value
        value = find_attr_value_('base', node)
        if value is not None and 'base' not in already_processed:
            already_processed.append('base')
            self.base = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
            self.type_ = ' '.join(self.type_.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class textType


class personType(GeneratedsSuper):
    """The Atom person construct is defined in section 3.2 of the format
    spec."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, base=None, name=None, uri=None, email=None, anytypeobjs_=None):
        self.lang = _cast(None, lang)
        self.base = _cast(None, base)
        self.name = name
        self.uri = uri
        self.email = email
        self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if personType.subclass:
            return personType.subclass(*args_, **kwargs_)
        else:
            return personType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def validate_emailType(self, value):
        # Validate type emailType, a restriction on xsd:normalizedString.
        pass
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_base(self): return self.base
    def set_base(self, base): self.base = base
    def export(self, outfile, level, namespace_='tns:', name_='personType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='personType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='personType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            outfile.write(' base=%s' % (self.gds_format_string(quote_attrib(self.base).encode(ExternalEncoding), input_name='base'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='personType', fromsubclass_=False):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('<%sname>%s</%sname>\n' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_))
        if self.uri is not None:
            self.uri.export(outfile, level, namespace_, name_='uri')
        if self.email is not None:
            showIndent(outfile, level)
            outfile.write('<%semail>%s</%semail>\n' % (namespace_, self.gds_format_string(quote_xml(self.email).encode(ExternalEncoding), input_name='email'), namespace_))
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.name is not None or
            self.uri is not None or
            self.email is not None or
            self.anytypeobjs_ is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='personType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            showIndent(outfile, level)
            outfile.write('base = "%s",\n' % (self.base,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.uri is not None:
            showIndent(outfile, level)
            outfile.write('uri=model_.uriType(\n')
            self.uri.exportLiteral(outfile, level, name_='uri')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.email is not None:
            showIndent(outfile, level)
            outfile.write('email=%s,\n' % quote_python(self.email).encode(ExternalEncoding))
        if self.anytypeobjs_ is not None:
            showIndent(outfile, level)
            outfile.write('anytypeobjs_=model_.anytypeobjs_(\n')
            self.anytypeobjs_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            self.lang = value
        value = find_attr_value_('base', node)
        if value is not None and 'base' not in already_processed:
            already_processed.append('base')
            self.base = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'uri':
            obj_ = uriType.factory()
            obj_.build(child_)
            self.set_uri(obj_)
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email = email_
            self.validate_emailType(self.email)    # validate type emailType
        else:
            obj_ = self.gds_build_any(child_, 'personType')
            if obj_ is not None:
                self.set_anytypeobjs_(obj_)
# end class personType


class feedType(GeneratedsSuper):
    """The Atom feed construct is defined in section 4.1.1 of the format
    spec."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, base=None, author=None, category=None, contributor=None, generator=None, icon=None, id=None, link=None, logo=None, rights=None, subtitle=None, title=None, updated=None, entry=None, anytypeobjs_=None):
        self.lang = _cast(None, lang)
        self.base = _cast(None, base)
        if author is None:
            self.author = []
        else:
            self.author = author
        if category is None:
            self.category = []
        else:
            self.category = category
        if contributor is None:
            self.contributor = []
        else:
            self.contributor = contributor
        self.generator = generator
        self.icon = icon
        self.id = id
        if link is None:
            self.link = []
        else:
            self.link = link
        self.logo = logo
        self.rights = rights
        self.subtitle = subtitle
        self.title = title
        self.updated = updated
        if entry is None:
            self.entry = []
        else:
            self.entry = entry
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if feedType.subclass:
            return feedType.subclass(*args_, **kwargs_)
        else:
            return feedType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_author(self): return self.author
    def set_author(self, author): self.author = author
    def add_author(self, value): self.author.append(value)
    def insert_author(self, index, value): self.author[index] = value
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def add_category(self, value): self.category.append(value)
    def insert_category(self, index, value): self.category[index] = value
    def get_contributor(self): return self.contributor
    def set_contributor(self, contributor): self.contributor = contributor
    def add_contributor(self, value): self.contributor.append(value)
    def insert_contributor(self, index, value): self.contributor[index] = value
    def get_generator(self): return self.generator
    def set_generator(self, generator): self.generator = generator
    def get_icon(self): return self.icon
    def set_icon(self, icon): self.icon = icon
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_link(self): return self.link
    def set_link(self, link): self.link = link
    def add_link(self, value): self.link.append(value)
    def insert_link(self, index, value): self.link[index] = value
    def get_logo(self): return self.logo
    def set_logo(self, logo): self.logo = logo
    def get_rights(self): return self.rights
    def set_rights(self, rights): self.rights = rights
    def get_subtitle(self): return self.subtitle
    def set_subtitle(self, subtitle): self.subtitle = subtitle
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_updated(self): return self.updated
    def set_updated(self, updated): self.updated = updated
    def get_entry(self): return self.entry
    def set_entry(self, entry): self.entry = entry
    def add_entry(self, value): self.entry.append(value)
    def insert_entry(self, index, value): self.entry[index] = value
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_base(self): return self.base
    def set_base(self, base): self.base = base
    def export(self, outfile, level, namespace_='tns:', name_='feedType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='feedType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='feedType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            outfile.write(' base=%s' % (self.gds_format_string(quote_attrib(self.base).encode(ExternalEncoding), input_name='base'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='feedType', fromsubclass_=False):
        for author_ in self.author:
            author_.export(outfile, level, namespace_, name_='author')
        for category_ in self.category:
            category_.export(outfile, level, namespace_, name_='category')
        for contributor_ in self.contributor:
            contributor_.export(outfile, level, namespace_, name_='contributor')
        if self.generator is not None:
            self.generator.export(outfile, level, namespace_, name_='generator')
        if self.icon is not None:
            self.icon.export(outfile, level, namespace_, name_='icon')
        if self.id is not None:
            self.id.export(outfile, level, namespace_, name_='id', )
        for link_ in self.link:
            link_.export(outfile, level, namespace_, name_='link')
        if self.logo is not None:
            self.logo.export(outfile, level, namespace_, name_='logo')
        if self.rights is not None:
            self.rights.export(outfile, level, namespace_, name_='rights')
        if self.subtitle is not None:
            self.subtitle.export(outfile, level, namespace_, name_='subtitle')
        if self.title is not None:
            self.title.export(outfile, level, namespace_, name_='title', )
        if self.updated is not None:
            self.updated.export(outfile, level, namespace_, name_='updated', )
        for entry_ in self.entry:
            entry_.export(outfile, level, namespace_, name_='entry')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.author or
            self.category or
            self.contributor or
            self.generator is not None or
            self.icon is not None or
            self.id is not None or
            self.link or
            self.logo is not None or
            self.rights is not None or
            self.subtitle is not None or
            self.title is not None or
            self.updated is not None or
            self.entry or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='feedType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            showIndent(outfile, level)
            outfile.write('base = "%s",\n' % (self.base,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('author=[\n')
        level += 1
        for author_ in self.author:
            showIndent(outfile, level)
            outfile.write('model_.personType(\n')
            author_.exportLiteral(outfile, level, name_='personType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('category=[\n')
        level += 1
        for category_ in self.category:
            showIndent(outfile, level)
            outfile.write('model_.categoryType(\n')
            category_.exportLiteral(outfile, level, name_='categoryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('contributor=[\n')
        level += 1
        for contributor_ in self.contributor:
            showIndent(outfile, level)
            outfile.write('model_.personType(\n')
            contributor_.exportLiteral(outfile, level, name_='personType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.generator is not None:
            showIndent(outfile, level)
            outfile.write('generator=model_.generatorType(\n')
            self.generator.exportLiteral(outfile, level, name_='generator')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.icon is not None:
            showIndent(outfile, level)
            outfile.write('icon=model_.iconType(\n')
            self.icon.exportLiteral(outfile, level, name_='icon')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=model_.idType(\n')
            self.id.exportLiteral(outfile, level, name_='id')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('link=[\n')
        level += 1
        for link_ in self.link:
            showIndent(outfile, level)
            outfile.write('model_.linkType(\n')
            link_.exportLiteral(outfile, level, name_='linkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.logo is not None:
            showIndent(outfile, level)
            outfile.write('logo=model_.logoType(\n')
            self.logo.exportLiteral(outfile, level, name_='logo')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rights is not None:
            showIndent(outfile, level)
            outfile.write('rights=model_.textType(\n')
            self.rights.exportLiteral(outfile, level, name_='rights')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.subtitle is not None:
            showIndent(outfile, level)
            outfile.write('subtitle=model_.textType(\n')
            self.subtitle.exportLiteral(outfile, level, name_='subtitle')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.title is not None:
            showIndent(outfile, level)
            outfile.write('title=model_.textType(\n')
            self.title.exportLiteral(outfile, level, name_='title')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.updated is not None:
            showIndent(outfile, level)
            outfile.write('updated=model_.dateTimeType(\n')
            self.updated.exportLiteral(outfile, level, name_='updated')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('entry=[\n')
        level += 1
        for entry_ in self.entry:
            showIndent(outfile, level)
            outfile.write('model_.entryType(\n')
            entry_.exportLiteral(outfile, level, name_='entryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            self.lang = value
        value = find_attr_value_('base', node)
        if value is not None and 'base' not in already_processed:
            already_processed.append('base')
            self.base = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'author':
            obj_ = personType.factory()
            obj_.build(child_)
            self.author.append(obj_)
        elif nodeName_ == 'category':
            obj_ = categoryType.factory()
            obj_.build(child_)
            self.category.append(obj_)
        elif nodeName_ == 'contributor':
            obj_ = personType.factory()
            obj_.build(child_)
            self.contributor.append(obj_)
        elif nodeName_ == 'generator':
            obj_ = generatorType.factory()
            obj_.build(child_)
            self.set_generator(obj_)
        elif nodeName_ == 'icon':
            obj_ = iconType.factory()
            obj_.build(child_)
            self.set_icon(obj_)
        elif nodeName_ == 'id':
            obj_ = idType.factory()
            obj_.build(child_)
            self.set_id(obj_)
        elif nodeName_ == 'link':
            obj_ = linkType.factory()
            obj_.build(child_)
            self.link.append(obj_)
        elif nodeName_ == 'logo':
            obj_ = logoType.factory()
            obj_.build(child_)
            self.set_logo(obj_)
        elif nodeName_ == 'rights':
            obj_ = textType.factory()
            obj_.build(child_)
            self.set_rights(obj_)
        elif nodeName_ == 'subtitle':
            obj_ = textType.factory()
            obj_.build(child_)
            self.set_subtitle(obj_)
        elif nodeName_ == 'title':
            obj_ = textType.factory()
            obj_.build(child_)
            self.set_title(obj_)
        elif nodeName_ == 'updated':
            obj_ = dateTimeType.factory()
            obj_.build(child_)
            self.set_updated(obj_)
        elif nodeName_ == 'entry':
            obj_ = entryType.factory()
            obj_.build(child_)
            self.entry.append(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'feedType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class feedType


class entryType(GeneratedsSuper):
    """The Atom entry construct is defined in section 4.1.2 of the format
    spec."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, base=None, author=None, category=None, content=None, contributor=None, id=None, link=None, published=None, rights=None, source=None, summary=None, title=None, updated=None, anytypeobjs_=None):
        self.lang = _cast(None, lang)
        self.base = _cast(None, base)
        if author is None:
            self.author = []
        else:
            self.author = author
        if category is None:
            self.category = []
        else:
            self.category = category
        self.content = content
        if contributor is None:
            self.contributor = []
        else:
            self.contributor = contributor
        self.id = id
        if link is None:
            self.link = []
        else:
            self.link = link
        self.published = published
        self.rights = rights
        self.source = source
        self.summary = summary
        self.title = title
        self.updated = updated
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if entryType.subclass:
            return entryType.subclass(*args_, **kwargs_)
        else:
            return entryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_author(self): return self.author
    def set_author(self, author): self.author = author
    def add_author(self, value): self.author.append(value)
    def insert_author(self, index, value): self.author[index] = value
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def add_category(self, value): self.category.append(value)
    def insert_category(self, index, value): self.category[index] = value
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def get_contributor(self): return self.contributor
    def set_contributor(self, contributor): self.contributor = contributor
    def add_contributor(self, value): self.contributor.append(value)
    def insert_contributor(self, index, value): self.contributor[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_link(self): return self.link
    def set_link(self, link): self.link = link
    def add_link(self, value): self.link.append(value)
    def insert_link(self, index, value): self.link[index] = value
    def get_published(self): return self.published
    def set_published(self, published): self.published = published
    def get_rights(self): return self.rights
    def set_rights(self, rights): self.rights = rights
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_summary(self): return self.summary
    def set_summary(self, summary): self.summary = summary
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_updated(self): return self.updated
    def set_updated(self, updated): self.updated = updated
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_base(self): return self.base
    def set_base(self, base): self.base = base
    def export(self, outfile, level, namespace_='tns:', name_='entryType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='entryType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='entryType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            outfile.write(' base=%s' % (self.gds_format_string(quote_attrib(self.base).encode(ExternalEncoding), input_name='base'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='entryType', fromsubclass_=False):
        for author_ in self.author:
            author_.export(outfile, level, namespace_, name_='author')
        for category_ in self.category:
            category_.export(outfile, level, namespace_, name_='category')
        if self.content is not None:
            self.content.export(outfile, level, namespace_, name_='content')
        for contributor_ in self.contributor:
            contributor_.export(outfile, level, namespace_, name_='contributor')
        if self.id is not None:
            self.id.export(outfile, level, namespace_, name_='id', )
        for link_ in self.link:
            link_.export(outfile, level, namespace_, name_='link')
        if self.published is not None:
            self.published.export(outfile, level, namespace_, name_='published')
        if self.rights is not None:
            self.rights.export(outfile, level, namespace_, name_='rights')
        if self.source is not None:
            self.source.export(outfile, level, namespace_, name_='source')
        if self.summary is not None:
            self.summary.export(outfile, level, namespace_, name_='summary')
        if self.title is not None:
            self.title.export(outfile, level, namespace_, name_='title', )
        if self.updated is not None:
            self.updated.export(outfile, level, namespace_, name_='updated', )
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.author or
            self.category or
            self.content is not None or
            self.contributor or
            self.id is not None or
            self.link or
            self.published is not None or
            self.rights is not None or
            self.source is not None or
            self.summary is not None or
            self.title is not None or
            self.updated is not None or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='entryType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            showIndent(outfile, level)
            outfile.write('base = "%s",\n' % (self.base,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('author=[\n')
        level += 1
        for author_ in self.author:
            showIndent(outfile, level)
            outfile.write('model_.personType(\n')
            author_.exportLiteral(outfile, level, name_='personType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('category=[\n')
        level += 1
        for category_ in self.category:
            showIndent(outfile, level)
            outfile.write('model_.categoryType(\n')
            category_.exportLiteral(outfile, level, name_='categoryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.content is not None:
            showIndent(outfile, level)
            outfile.write('content=model_.contentType(\n')
            self.content.exportLiteral(outfile, level, name_='content')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('contributor=[\n')
        level += 1
        for contributor_ in self.contributor:
            showIndent(outfile, level)
            outfile.write('model_.personType(\n')
            contributor_.exportLiteral(outfile, level, name_='personType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=model_.idType(\n')
            self.id.exportLiteral(outfile, level, name_='id')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('link=[\n')
        level += 1
        for link_ in self.link:
            showIndent(outfile, level)
            outfile.write('model_.linkType(\n')
            link_.exportLiteral(outfile, level, name_='linkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.published is not None:
            showIndent(outfile, level)
            outfile.write('published=model_.dateTimeType(\n')
            self.published.exportLiteral(outfile, level, name_='published')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rights is not None:
            showIndent(outfile, level)
            outfile.write('rights=model_.textType(\n')
            self.rights.exportLiteral(outfile, level, name_='rights')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.source is not None:
            showIndent(outfile, level)
            outfile.write('source=model_.textType(\n')
            self.source.exportLiteral(outfile, level, name_='source')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.summary is not None:
            showIndent(outfile, level)
            outfile.write('summary=model_.textType(\n')
            self.summary.exportLiteral(outfile, level, name_='summary')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.title is not None:
            showIndent(outfile, level)
            outfile.write('title=model_.textType(\n')
            self.title.exportLiteral(outfile, level, name_='title')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.updated is not None:
            showIndent(outfile, level)
            outfile.write('updated=model_.dateTimeType(\n')
            self.updated.exportLiteral(outfile, level, name_='updated')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            self.lang = value
        value = find_attr_value_('base', node)
        if value is not None and 'base' not in already_processed:
            already_processed.append('base')
            self.base = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'author':
            obj_ = personType.factory()
            obj_.build(child_)
            self.author.append(obj_)
        elif nodeName_ == 'category':
            obj_ = categoryType.factory()
            obj_.build(child_)
            self.category.append(obj_)
        elif nodeName_ == 'content':
            obj_ = contentType.factory()
            obj_.build(child_)
            self.set_content(obj_)
        elif nodeName_ == 'contributor':
            obj_ = personType.factory()
            obj_.build(child_)
            self.contributor.append(obj_)
        elif nodeName_ == 'id':
            obj_ = idType.factory()
            obj_.build(child_)
            self.set_id(obj_)
        elif nodeName_ == 'link':
            obj_ = linkType.factory()
            obj_.build(child_)
            self.link.append(obj_)
        elif nodeName_ == 'published':
            obj_ = dateTimeType.factory()
            obj_.build(child_)
            self.set_published(obj_)
        elif nodeName_ == 'rights':
            obj_ = textType.factory()
            obj_.build(child_)
            self.set_rights(obj_)
        elif nodeName_ == 'source':
            obj_ = textType.factory()
            obj_.build(child_)
            self.set_source(obj_)
        elif nodeName_ == 'summary':
            obj_ = textType.factory()
            obj_.build(child_)
            self.set_summary(obj_)
        elif nodeName_ == 'title':
            obj_ = textType.factory()
            obj_.build(child_)
            self.set_title(obj_)
        elif nodeName_ == 'updated':
            obj_ = dateTimeType.factory()
            obj_.build(child_)
            self.set_updated(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'entryType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class entryType


class contentType(GeneratedsSuper):
    """The Atom content construct is defined in section 4.1.3 of the format
    spec."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, src=None, base=None, type_=None, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.lang = _cast(None, lang)
        self.src = _cast(None, src)
        self.base = _cast(None, base)
        self.type_ = _cast(None, type_)
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if contentType.subclass:
            return contentType.subclass(*args_, **kwargs_)
        else:
            return contentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_src(self): return self.src
    def set_src(self, src): self.src = src
    def get_base(self): return self.base
    def set_base(self, base): self.base = base
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='tns:', name_='contentType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='contentType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='contentType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.src is not None and 'src' not in already_processed:
            already_processed.append('src')
            outfile.write(' src=%s' % (self.gds_format_string(quote_attrib(self.src).encode(ExternalEncoding), input_name='src'), ))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            outfile.write(' base=%s' % (self.gds_format_string(quote_attrib(self.base).encode(ExternalEncoding), input_name='base'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='contentType', fromsubclass_=False):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_)
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='contentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
        if self.src is not None and 'src' not in already_processed:
            already_processed.append('src')
            showIndent(outfile, level)
            outfile.write('src = "%s",\n' % (self.src,))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            showIndent(outfile, level)
            outfile.write('base = "%s",\n' % (self.base,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content_ = [\n')
        for item_ in self.content_:
            item_.exportLiteral(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('],\n')
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            self.lang = value
        value = find_attr_value_('src', node)
        if value is not None and 'src' not in already_processed:
            already_processed.append('src')
            self.src = value
        value = find_attr_value_('base', node)
        if value is not None and 'base' not in already_processed:
            already_processed.append('base')
            self.base = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class contentType


class categoryType(GeneratedsSuper):
    """The Atom cagegory construct is defined in section 4.2.2 of the
    format spec."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, term=None, scheme=None, base=None, label=None):
        self.lang = _cast(None, lang)
        self.term = _cast(None, term)
        self.scheme = _cast(None, scheme)
        self.base = _cast(None, base)
        self.label = _cast(None, label)
        pass
    def factory(*args_, **kwargs_):
        if categoryType.subclass:
            return categoryType.subclass(*args_, **kwargs_)
        else:
            return categoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_term(self): return self.term
    def set_term(self, term): self.term = term
    def get_scheme(self): return self.scheme
    def set_scheme(self, scheme): self.scheme = scheme
    def get_base(self): return self.base
    def set_base(self, base): self.base = base
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def export(self, outfile, level, namespace_='tns:', name_='categoryType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='categoryType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='categoryType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.term is not None and 'term' not in already_processed:
            already_processed.append('term')
            outfile.write(' term=%s' % (self.gds_format_string(quote_attrib(self.term).encode(ExternalEncoding), input_name='term'), ))
        if self.scheme is not None and 'scheme' not in already_processed:
            already_processed.append('scheme')
            outfile.write(' scheme=%s' % (self.gds_format_string(quote_attrib(self.scheme).encode(ExternalEncoding), input_name='scheme'), ))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            outfile.write(' base=%s' % (self.gds_format_string(quote_attrib(self.base).encode(ExternalEncoding), input_name='base'), ))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            outfile.write(' label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='categoryType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='categoryType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
        if self.term is not None and 'term' not in already_processed:
            already_processed.append('term')
            showIndent(outfile, level)
            outfile.write('term = "%s",\n' % (self.term,))
        if self.scheme is not None and 'scheme' not in already_processed:
            already_processed.append('scheme')
            showIndent(outfile, level)
            outfile.write('scheme = "%s",\n' % (self.scheme,))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            showIndent(outfile, level)
            outfile.write('base = "%s",\n' % (self.base,))
        if self.label is not None and 'label' not in already_processed:
            already_processed.append('label')
            showIndent(outfile, level)
            outfile.write('label = "%s",\n' % (self.label,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            self.lang = value
        value = find_attr_value_('term', node)
        if value is not None and 'term' not in already_processed:
            already_processed.append('term')
            self.term = value
        value = find_attr_value_('scheme', node)
        if value is not None and 'scheme' not in already_processed:
            already_processed.append('scheme')
            self.scheme = value
        value = find_attr_value_('base', node)
        if value is not None and 'base' not in already_processed:
            already_processed.append('base')
            self.base = value
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.append('label')
            self.label = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class categoryType


class generatorType(GeneratedsSuper):
    """The Atom generator element is defined in section 4.2.4 of the format
    spec."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, version=None, uri=None, base=None, valueOf_=None):
        self.lang = _cast(None, lang)
        self.version = _cast(None, version)
        self.uri = _cast(None, uri)
        self.base = _cast(None, base)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if generatorType.subclass:
            return generatorType.subclass(*args_, **kwargs_)
        else:
            return generatorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def get_base(self): return self.base
    def set_base(self, base): self.base = base
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='tns:', name_='generatorType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='generatorType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='generatorType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.append('uri')
            outfile.write(' uri=%s' % (self.gds_format_string(quote_attrib(self.uri).encode(ExternalEncoding), input_name='uri'), ))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            outfile.write(' base=%s' % (self.gds_format_string(quote_attrib(self.base).encode(ExternalEncoding), input_name='base'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='generatorType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='generatorType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.append('version')
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.append('uri')
            showIndent(outfile, level)
            outfile.write('uri = "%s",\n' % (self.uri,))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            showIndent(outfile, level)
            outfile.write('base = "%s",\n' % (self.base,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            self.lang = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.append('version')
            self.version = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.append('uri')
            self.uri = value
        value = find_attr_value_('base', node)
        if value is not None and 'base' not in already_processed:
            already_processed.append('base')
            self.base = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class generatorType


class iconType(GeneratedsSuper):
    """The Atom icon construct is defined in section 4.2.5 of the format
    spec."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, base=None, valueOf_=None):
        self.lang = _cast(None, lang)
        self.base = _cast(None, base)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if iconType.subclass:
            return iconType.subclass(*args_, **kwargs_)
        else:
            return iconType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_base(self): return self.base
    def set_base(self, base): self.base = base
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='tns:', name_='iconType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='iconType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='iconType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            outfile.write(' base=%s' % (self.gds_format_string(quote_attrib(self.base).encode(ExternalEncoding), input_name='base'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='iconType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='iconType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            showIndent(outfile, level)
            outfile.write('base = "%s",\n' % (self.base,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            self.lang = value
        value = find_attr_value_('base', node)
        if value is not None and 'base' not in already_processed:
            already_processed.append('base')
            self.base = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class iconType


class idType(GeneratedsSuper):
    """The Atom id construct is defined in section 4.2.6 of the format
    spec."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, base=None, valueOf_=None):
        self.lang = _cast(None, lang)
        self.base = _cast(None, base)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if idType.subclass:
            return idType.subclass(*args_, **kwargs_)
        else:
            return idType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_base(self): return self.base
    def set_base(self, base): self.base = base
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='tns:', name_='idType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='idType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='idType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            outfile.write(' base=%s' % (self.gds_format_string(quote_attrib(self.base).encode(ExternalEncoding), input_name='base'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='idType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='idType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            showIndent(outfile, level)
            outfile.write('base = "%s",\n' % (self.base,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            self.lang = value
        value = find_attr_value_('base', node)
        if value is not None and 'base' not in already_processed:
            already_processed.append('base')
            self.base = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class idType


class linkType(GeneratedsSuper):
    """The Atom link construct is defined in section 3.4 of the format
    spec."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, title=None, hreflang=None, length=None, href=None, rel=None, base=None, type_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.lang = _cast(None, lang)
        self.title = _cast(None, title)
        self.hreflang = _cast(None, hreflang)
        self.length = _cast(int, length)
        self.href = _cast(None, href)
        self.rel = _cast(None, rel)
        self.base = _cast(None, base)
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if linkType.subclass:
            return linkType.subclass(*args_, **kwargs_)
        else:
            return linkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_hreflang(self): return self.hreflang
    def set_hreflang(self, hreflang): self.hreflang = hreflang
    def get_length(self): return self.length
    def set_length(self, length): self.length = length
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def get_rel(self): return self.rel
    def set_rel(self, rel): self.rel = rel
    def get_base(self): return self.base
    def set_base(self, base): self.base = base
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='tns:', name_='linkType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='linkType')
        outfile.write('>')
        self.exportChildren(outfile, level + 1, namespace_, name_)
        outfile.write('</%s%s>\n' % (namespace_, name_))
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='linkType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            outfile.write(' title=%s' % (self.gds_format_string(quote_attrib(self.title).encode(ExternalEncoding), input_name='title'), ))
        if self.hreflang is not None and 'hreflang' not in already_processed:
            already_processed.append('hreflang')
            outfile.write(' hreflang=%s' % (self.gds_format_string(quote_attrib(self.hreflang).encode(ExternalEncoding), input_name='hreflang'), ))
        if self.length is not None and 'length' not in already_processed:
            already_processed.append('length')
            outfile.write(' length="%s"' % self.gds_format_integer(self.length, input_name='length'))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
        if self.rel is not None and 'rel' not in already_processed:
            already_processed.append('rel')
            outfile.write(' rel=%s' % (self.gds_format_string(quote_attrib(self.rel).encode(ExternalEncoding), input_name='rel'), ))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            outfile.write(' base=%s' % (self.gds_format_string(quote_attrib(self.base).encode(ExternalEncoding), input_name='base'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='linkType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='linkType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
        if self.title is not None and 'title' not in already_processed:
            already_processed.append('title')
            showIndent(outfile, level)
            outfile.write('title = "%s",\n' % (self.title,))
        if self.hreflang is not None and 'hreflang' not in already_processed:
            already_processed.append('hreflang')
            showIndent(outfile, level)
            outfile.write('hreflang = "%s",\n' % (self.hreflang,))
        if self.length is not None and 'length' not in already_processed:
            already_processed.append('length')
            showIndent(outfile, level)
            outfile.write('length = %d,\n' % (self.length,))
        if self.href is not None and 'href' not in already_processed:
            already_processed.append('href')
            showIndent(outfile, level)
            outfile.write('href = "%s",\n' % (self.href,))
        if self.rel is not None and 'rel' not in already_processed:
            already_processed.append('rel')
            showIndent(outfile, level)
            outfile.write('rel = "%s",\n' % (self.rel,))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            showIndent(outfile, level)
            outfile.write('base = "%s",\n' % (self.base,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            self.lang = value
        value = find_attr_value_('title', node)
        if value is not None and 'title' not in already_processed:
            already_processed.append('title')
            self.title = value
        value = find_attr_value_('hreflang', node)
        if value is not None and 'hreflang' not in already_processed:
            already_processed.append('hreflang')
            self.hreflang = value
        value = find_attr_value_('length', node)
        if value is not None and 'length' not in already_processed:
            already_processed.append('length')
            try:
                self.length = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.length <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.append('href')
            self.href = value
        value = find_attr_value_('rel', node)
        if value is not None and 'rel' not in already_processed:
            already_processed.append('rel')
            self.rel = value
        value = find_attr_value_('base', node)
        if value is not None and 'base' not in already_processed:
            already_processed.append('base')
            self.base = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        pass
# end class linkType


class logoType(GeneratedsSuper):
    """The Atom logo construct is defined in section 4.2.8 of the format
    spec."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, base=None, valueOf_=None):
        self.lang = _cast(None, lang)
        self.base = _cast(None, base)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if logoType.subclass:
            return logoType.subclass(*args_, **kwargs_)
        else:
            return logoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_base(self): return self.base
    def set_base(self, base): self.base = base
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='tns:', name_='logoType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='logoType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='logoType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            outfile.write(' base=%s' % (self.gds_format_string(quote_attrib(self.base).encode(ExternalEncoding), input_name='base'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='logoType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='logoType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            showIndent(outfile, level)
            outfile.write('base = "%s",\n' % (self.base,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            self.lang = value
        value = find_attr_value_('base', node)
        if value is not None and 'base' not in already_processed:
            already_processed.append('base')
            self.base = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class logoType


class sourceType(GeneratedsSuper):
    """The Atom source construct is defined in section 4.2.11 of the format
    spec."""
    subclass = None
    superclass = None
    def __init__(self, lang=None, base=None, author=None, category=None, contributor=None, generator=None, icon=None, id=None, link=None, logo=None, rights=None, subtitle=None, title=None, updated=None, anytypeobjs_=None):
        self.lang = _cast(None, lang)
        self.base = _cast(None, base)
        if author is None:
            self.author = []
        else:
            self.author = author
        if category is None:
            self.category = []
        else:
            self.category = category
        if contributor is None:
            self.contributor = []
        else:
            self.contributor = contributor
        self.generator = generator
        self.icon = icon
        self.id = id
        if link is None:
            self.link = []
        else:
            self.link = link
        self.logo = logo
        self.rights = rights
        self.subtitle = subtitle
        self.title = title
        self.updated = updated
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
    def factory(*args_, **kwargs_):
        if sourceType.subclass:
            return sourceType.subclass(*args_, **kwargs_)
        else:
            return sourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_author(self): return self.author
    def set_author(self, author): self.author = author
    def add_author(self, value): self.author.append(value)
    def insert_author(self, index, value): self.author[index] = value
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def add_category(self, value): self.category.append(value)
    def insert_category(self, index, value): self.category[index] = value
    def get_contributor(self): return self.contributor
    def set_contributor(self, contributor): self.contributor = contributor
    def add_contributor(self, value): self.contributor.append(value)
    def insert_contributor(self, index, value): self.contributor[index] = value
    def get_generator(self): return self.generator
    def set_generator(self, generator): self.generator = generator
    def get_icon(self): return self.icon
    def set_icon(self, icon): self.icon = icon
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_link(self): return self.link
    def set_link(self, link): self.link = link
    def add_link(self, value): self.link.append(value)
    def insert_link(self, index, value): self.link[index] = value
    def get_logo(self): return self.logo
    def set_logo(self, logo): self.logo = logo
    def get_rights(self): return self.rights
    def set_rights(self, rights): self.rights = rights
    def get_subtitle(self): return self.subtitle
    def set_subtitle(self, subtitle): self.subtitle = subtitle
    def get_title(self): return self.title
    def set_title(self, title): self.title = title
    def get_updated(self): return self.updated
    def set_updated(self, updated): self.updated = updated
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_base(self): return self.base
    def set_base(self, base): self.base = base
    def export(self, outfile, level, namespace_='tns:', name_='sourceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='sourceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='sourceType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            outfile.write(' base=%s' % (self.gds_format_string(quote_attrib(self.base).encode(ExternalEncoding), input_name='base'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='sourceType', fromsubclass_=False):
        for author_ in self.author:
            author_.export(outfile, level, namespace_, name_='author')
        for category_ in self.category:
            category_.export(outfile, level, namespace_, name_='category')
        for contributor_ in self.contributor:
            contributor_.export(outfile, level, namespace_, name_='contributor')
        if self.generator is not None:
            self.generator.export(outfile, level, namespace_, name_='generator')
        if self.icon is not None:
            self.icon.export(outfile, level, namespace_, name_='icon')
        if self.id is not None:
            self.id.export(outfile, level, namespace_, name_='id')
        for link_ in self.link:
            link_.export(outfile, level, namespace_, name_='link')
        if self.logo is not None:
            self.logo.export(outfile, level, namespace_, name_='logo')
        if self.rights is not None:
            self.rights.export(outfile, level, namespace_, name_='rights')
        if self.subtitle is not None:
            self.subtitle.export(outfile, level, namespace_, name_='subtitle')
        if self.title is not None:
            self.title.export(outfile, level, namespace_, name_='title')
        if self.updated is not None:
            self.updated.export(outfile, level, namespace_, name_='updated')
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_)
    def hasContent_(self):
        if (
            self.author or
            self.category or
            self.contributor or
            self.generator is not None or
            self.icon is not None or
            self.id is not None or
            self.link or
            self.logo is not None or
            self.rights is not None or
            self.subtitle is not None or
            self.title is not None or
            self.updated is not None or
            self.anytypeobjs_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='sourceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            showIndent(outfile, level)
            outfile.write('base = "%s",\n' % (self.base,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('author=[\n')
        level += 1
        for author_ in self.author:
            showIndent(outfile, level)
            outfile.write('model_.personType(\n')
            author_.exportLiteral(outfile, level, name_='personType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('category=[\n')
        level += 1
        for category_ in self.category:
            showIndent(outfile, level)
            outfile.write('model_.categoryType(\n')
            category_.exportLiteral(outfile, level, name_='categoryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('contributor=[\n')
        level += 1
        for contributor_ in self.contributor:
            showIndent(outfile, level)
            outfile.write('model_.personType(\n')
            contributor_.exportLiteral(outfile, level, name_='personType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.generator is not None:
            showIndent(outfile, level)
            outfile.write('generator=model_.generatorType(\n')
            self.generator.exportLiteral(outfile, level, name_='generator')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.icon is not None:
            showIndent(outfile, level)
            outfile.write('icon=model_.iconType(\n')
            self.icon.exportLiteral(outfile, level, name_='icon')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id=model_.idType(\n')
            self.id.exportLiteral(outfile, level, name_='id')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('link=[\n')
        level += 1
        for link_ in self.link:
            showIndent(outfile, level)
            outfile.write('model_.linkType(\n')
            link_.exportLiteral(outfile, level, name_='linkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.logo is not None:
            showIndent(outfile, level)
            outfile.write('logo=model_.logoType(\n')
            self.logo.exportLiteral(outfile, level, name_='logo')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rights is not None:
            showIndent(outfile, level)
            outfile.write('rights=model_.textType(\n')
            self.rights.exportLiteral(outfile, level, name_='rights')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.subtitle is not None:
            showIndent(outfile, level)
            outfile.write('subtitle=model_.textType(\n')
            self.subtitle.exportLiteral(outfile, level, name_='subtitle')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.title is not None:
            showIndent(outfile, level)
            outfile.write('title=model_.textType(\n')
            self.title.exportLiteral(outfile, level, name_='title')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.updated is not None:
            showIndent(outfile, level)
            outfile.write('updated=model_.dateTimeType(\n')
            self.updated.exportLiteral(outfile, level, name_='updated')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('anytypeobjs_=[\n')
        level += 1
        for anytypeobjs_ in self.anytypeobjs_:
            anytypeobjs_.exportLiteral(outfile, level)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            self.lang = value
        value = find_attr_value_('base', node)
        if value is not None and 'base' not in already_processed:
            already_processed.append('base')
            self.base = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'author':
            obj_ = personType.factory()
            obj_.build(child_)
            self.author.append(obj_)
        elif nodeName_ == 'category':
            obj_ = categoryType.factory()
            obj_.build(child_)
            self.category.append(obj_)
        elif nodeName_ == 'contributor':
            obj_ = personType.factory()
            obj_.build(child_)
            self.contributor.append(obj_)
        elif nodeName_ == 'generator':
            obj_ = generatorType.factory()
            obj_.build(child_)
            self.set_generator(obj_)
        elif nodeName_ == 'icon':
            obj_ = iconType.factory()
            obj_.build(child_)
            self.set_icon(obj_)
        elif nodeName_ == 'id':
            obj_ = idType.factory()
            obj_.build(child_)
            self.set_id(obj_)
        elif nodeName_ == 'link':
            obj_ = linkType.factory()
            obj_.build(child_)
            self.link.append(obj_)
        elif nodeName_ == 'logo':
            obj_ = logoType.factory()
            obj_.build(child_)
            self.set_logo(obj_)
        elif nodeName_ == 'rights':
            obj_ = textType.factory()
            obj_.build(child_)
            self.set_rights(obj_)
        elif nodeName_ == 'subtitle':
            obj_ = textType.factory()
            obj_.build(child_)
            self.set_subtitle(obj_)
        elif nodeName_ == 'title':
            obj_ = textType.factory()
            obj_.build(child_)
            self.set_title(obj_)
        elif nodeName_ == 'updated':
            obj_ = dateTimeType.factory()
            obj_.build(child_)
            self.set_updated(obj_)
        else:
            obj_ = self.gds_build_any(child_, 'sourceType')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class sourceType


class uriType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, lang=None, base=None, valueOf_=None):
        self.lang = _cast(None, lang)
        self.base = _cast(None, base)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if uriType.subclass:
            return uriType.subclass(*args_, **kwargs_)
        else:
            return uriType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_base(self): return self.base
    def set_base(self, base): self.base = base
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='tns:', name_='uriType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='uriType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='uriType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            outfile.write(' base=%s' % (self.gds_format_string(quote_attrib(self.base).encode(ExternalEncoding), input_name='base'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='uriType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='uriType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            showIndent(outfile, level)
            outfile.write('base = "%s",\n' % (self.base,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            self.lang = value
        value = find_attr_value_('base', node)
        if value is not None and 'base' not in already_processed:
            already_processed.append('base')
            self.base = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class uriType


class dateTimeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, lang=None, base=None, valueOf_=None):
        self.lang = _cast(None, lang)
        self.base = _cast(None, base)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if dateTimeType.subclass:
            return dateTimeType.subclass(*args_, **kwargs_)
        else:
            return dateTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_base(self): return self.base
    def set_base(self, base): self.base = base
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='tns:', name_='dateTimeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='dateTimeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='tns:', name_='dateTimeType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            outfile.write(' base=%s' % (self.gds_format_string(quote_attrib(self.base).encode(ExternalEncoding), input_name='base'), ))
    def exportChildren(self, outfile, level, namespace_='tns:', name_='dateTimeType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='dateTimeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            showIndent(outfile, level)
            outfile.write('lang = "%s",\n' % (self.lang,))
        if self.base is not None and 'base' not in already_processed:
            already_processed.append('base')
            showIndent(outfile, level)
            outfile.write('base = "%s",\n' % (self.base,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.append('lang')
            self.lang = value
        value = find_attr_value_('base', node)
        if value is not None and 'base' not in already_processed:
            already_processed.append('base')
            self.base = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class dateTimeType


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'loadBalancers'
        rootClass = loadBalancers
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag, 
        namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'loadBalancers'
        rootClass = loadBalancers
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="loadBalancers",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'loadBalancers'
        rootClass = loadBalancers
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from LbApi import *\n\n')
    sys.stdout.write('import LbApi as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "absolute",
    "accessList",
    "accountBilling",
    "accountUsage",
    "accountUsageRecord",
    "algorithm",
    "algorithms",
    "allowedDomain",
    "allowedDomains",
    "categoryType",
    "cluster",
    "connectionLogging",
    "connectionThrottle",
    "contentType",
    "created",
    "dateTimeType",
    "entryType",
    "errorpage",
    "feedType",
    "generatorType",
    "healthMonitor",
    "iconType",
    "idType",
    "limit",
    "limitType",
    "limitTypes",
    "limits",
    "linkType",
    "loadBalancer",
    "loadBalancerUsage",
    "loadBalancerUsageRecord",
    "loadBalancers",
    "logoType",
    "meta",
    "metadata",
    "networkItem",
    "node",
    "nodes",
    "operationresponse",
    "personType",
    "protocol",
    "protocols",
    "sessionPersistence",
    "sourceAddresses",
    "sourceType",
    "sslTermination",
    "stats",
    "textType",
    "updated",
    "uriType",
    "virtualIp",
    "virtualIps"
    ]
